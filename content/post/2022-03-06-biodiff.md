---
title: "biodiff"
date: 2022-03-06T00:00:00-07:00
draft: false
---

[biodiff](https://github.com/8051Enthusiast/biodiff) is a binary diffing tool by [@8051enthusiast](https://twitter.com/8051enthusiast).
You can use this tool to identify additions, removals, and changes between two files, even if they're not text files.
I anticipate this to be useful during malware analysis, such as to highlight configuration changes among variants of the same malware family.

In the past, I've used [010 Editor](https://www.sweetscape.com/010editor/) for this; however, it requires a lot of pointy-clicky GUI interactions.
biodiff may be a better fit for strictly diff-ing within a terminal.

Other analysts may use [vbindiff](https://www.cjmweb.net/vbindiff/), though [u/northbound-goat](https://www.reddit.com/r/rust/comments/t7g1gd/comment/hzjuaue/) shares:

> (unless I was using it wrong all the time) it can realistically only compare headers (or beginnings of manually prepared files), as the comparison breaks after the first variable length part that's different in the two files.

`biodiff` uses algorithms from bioinformatics (think DNA sequencing) to find better alignment within files.


### example: finding malware configuration changes

Imagine you've recovered two similar-looking malware payloads during an incident:

| filename    | size (bytes) | magic                                         |
| ----------- | ------------ | --------------------------------------------- |
| [virus.exe](https://www.virustotal.com/gui/file/bd960ceb2ea4dc5f16988120d8e710a7f7e7990a7adf51c3292aa64f1bc20061) | 7168         | PE32+ executable (GUI) x86-64, for MS Windows |
| [hacker.exe](https://www.virustotal.com/gui/file/6614fcdf514992b7199d7e6643b924ad340ccd258dcd4779a4b330e4a80bad2a) | 7168         | PE32+ executable (GUI) x86-64, for MS Windows |

You do a quick triage and see that they have a similar structure, by using `objdump` to enumerate sections, etc. and comparing the reports:

![image alt text](/img/biodiff3.jpg)

This shows two differences:
  1. the PE header checksum
  2. the first section name

However, `diff objdump` doesn't explain if/how the code differs.

You can approximate a content comparison by diffing the strings of the two files,
but there are obvious reasons why this doesn't work well:
it only considers data with a human-readable representation, etc.
Still you can try it, though the results are not very useful:

![image alt text](/img/biodiff2.jpg)

This is a perfect time to use `biodiff`!
Here's what it looks like:

![image alt text](/img/biodiff1.jpg)

biodiff displays hex dumps of the two files side-by-side and highlights changes.
It found three differences:

  1. PE header checksum (known from `objdump`)
  2. the second section's name (known from `objdump`)
  3. six code changes around offset 0x1810 (new!)

Let's triage the code changes to see if any are meaningful.
Here is what biodiff shows:

![image alt text](/img/biodiff4.jpg)

Red indicates content that has changed, while green indicates content that has been added (and empty space is content that's been removed).

Of these code changes, the first five are instruction reorderings that we can ignore:

![image alt text](/img/biodiff5.jpg)

and the final is a *meaningful* change of an immediate constant:

![image alt text](/img/biodiff6.jpg)

With a bit more inspection (or perhaps by recognizing that these are Metasploit payloads)
you can realize that these constants are the `sin_port` and `sin_addr` fields of a `struct sockaddr_in`:

```c
struct sockaddr_in {
    short   sin_family;
    u_short sin_port;
    struct  in_addr sin_addr;
    char    sin_zero[8];
};
```

Which means that this final difference corresponds to the C2 server used by these backdoors.
You can decode them with a bit of python:

`11 5C C0 A8 01 21`:


```py
In [1]: import struct, socket

In [2]: "{1}:{0}".format(
   ...:     struct.unpack_from("<H", bytes.fromhex("115C"))[0],
   ...:     socket.inet_ntoa(bytes.fromhex("C0A80121")),
   ...: )
Out[2]: '192.168.1.33:23569'
```

`5B 26 2F 5F 0D A8`:

```py
In [1]: import struct, socket

In [2]: "{1}:{0}".format(
   ...:     struct.unpack_from("<H", bytes.fromhex("5B26"))[0],
   ...:     socket.inet_ntoa(bytes.fromhex("2F5F0DA8")),
   ...: )
Out[2]: '47.95.13.168:9819'
```
