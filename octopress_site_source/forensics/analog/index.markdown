---
layout: page
title: "Analog Cache Forensics"
date: 2013-01-13 19:54
comments: false
sharing: false
footer: true
---

[Analog](http://www.analog.cx) is a logfile analyzer. Its website bills the tool as "the most popular logfile analyzer in the world". This tool reads web server logs and produces nice reports with graphs and other diagrams to give you a warm fuzzy feeling of productivity. 
Recently I performed forensics on a web server with few surviving logs. Although access and error logs were not available, I used the cache file generated by Analog to identify successful SQL injection attacks. I wasn't able to find much documentation on the Analog cache file, so I've published some here. 

Because Analog periodically generates reports across millions of messages, the author developed a caching system to speed up report generation. The cache file is meant to be opaque, but with a bit of extra attention, we can gain some insight. This cache file is a plain text file that is easily parsed. 

Generally speaking, Analog tracks information about a number of items, including at least the following items: 

 -  URLs requested
 -  Referers
 -  User Agents
 -  IP addresses 

For each of these items, Analog tracks at least the following data: 

 -  First seen date
 -  Last seen date
 -  Request count
 -  Successful requests with item
 -  Failed requests with item
 -  Redirected requests with item
 -  Bytes transferred with item 

As far as I can tell, Analog processes dates as they are generated by the web server. For example, if Apache generates log entries as GMT-0400, Analog will process the local time of the server. When storing dates, Analog uses a somewhat non-standard format: minutes since the epoch. 

I will first include an [example](#example) Analog cache file as a reference so you know what I'm talking about. I will next describe the Analog 6.0 cache [file format](#format) to the best of my understanding. Finally, I will also provide a [program to decode](#decoder) the date format used by Analog. 

Example Analog 6.0 Cache File <a id="example"></a>
-----------------------------

{% codeblock %}
    CACHE type 5 produced by analog 6.0/Unix. Do not modify or delete!
    T       0       0       123456  12345   1234    1234    1234567890
    D       12345678        12345678
    12345   123     1       0       12345
    12345   124     1       0       12345
    12345   125     1       0       12345
    1       100     75     10       15      12345678        0       0       12345678        0       0       123456  /index.html
    3       100     75     10       15      12345678        0       0       12345678        0       0       123456  http://www.google.com?q=lolcats
    4       100     75     10       15      12345678        0       0       12345678        0       0       123456  Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0;)
    5       100     75     10       15      12345678        0       0       12345678        0       0       123456  127.0.0.1
    z       0       12345   1234    12345678        1
    z       1       123     1       12345678        1234
    c       200     123456  12345678
    c       206     123     12345678
    c       301     123     12345678
    c       302     1234    12345678
    c       304     12345   12345678
    c       400     12      12345678
    c       401     12      12345678
    c       403     1       12345678
    c       404     1234    12345678
    c       405     12      12345678
    c       500     1       12345678
    p       ???     ???     ???      ???    ???   ???
{% endcodeblock %}    

Analog 6.0 Cache Format <a id="format"></a>
-----------------------

### Header 

The first line of the file will be the header: 

{% codeblock %}
    CACHE type 5 produced by analog 6.0/Unix. Do not modify or delete!
{% endcodeblock %}

The following code generates the header: 

{% codeblock lang:c %}
    /* src/cache.c line 61 */
    fprintf(outf,
            "CACHE type 5 produced by analog %s. Do not modify or delete!n",
            VERSION);
{% endcodeblock %}

    
### Summary 

The second line contains a summary of all requests processed by Analog. The first character of the line will be the character 'T'.

{% codeblock %}
    KEY   UNKNOWN  INFO   SUCCESSES PAGES REDIRECTS FAILURES  BYTES
    |       |       |         |       |      |       |         |
    V       V       V         V       V      V       V         V
    T       0       0       123456  12345   1234    1234    1234567890
{% endcodeblock %}

The following code generates the summary: 

{% codeblock lang:c %}
    /* src/cache.c line 65 */
    fprintf(outf, "Tt%lut%lut%lut%lut%lut%lut%.0fn",
            data[LOGDATA_UNKNOWN], data[LOGDATA_INFO], data[LOGDATA_SUCC],
            data[LOGDATA_PAGES], data[LOGDATA_REDIR], data[LOGDATA_FAIL], bys);
{% endcodeblock %}


### Date Information 

The next lines contain a summary of date information. The first line specifies the time period tracked by Analog. This line will begin with the character 'D', and will have three tab-separated columns. The columns are: 

 -  D (Character)
 -  First Time (Date)
 -  Last Time (Date) 

The following lines describe the activity over time. I do not have a good understanding of the activity vs. time section. Each line has five tab-separated columns. The columns may be: 

 -  ??? (Large Integer)
 -  Index (Integer)
 -  Requests (Integer)
 -  Pages (Integer)
 -  Bytes Transferred (Integer)

{% codeblock %}
    KEY     FIRSTTIME       LASTTIME
    |          |               |
    V          V               V
    D       12345678        12345678

    DATE?  INDEX  REQS    PAGES     BYTES    
    |        |      |       |         |
    V        V      V       V         V
    12345   123     1       0       12345
    12345   124     1       0       12345
    12345   125     1       0       12345
{% endcodeblock %}

The following code generates the date information: 

{% codeblock lang:c %}
    /* src/cache.c line 70 */
    if (dman->firsttime == LAST_TIME && dman->lasttime == FIRST_TIME)
      fprintf(outf, "Dt%lut%lun", dman->lasttime, dman->firsttime);
    else
      fprintf(outf, "Dt%lut%lun", dman->firsttime, dman->lasttime);
    for (k = dman->firstdate, dp = dman->firstdp; dp != NULL;
         k%2B%2B, TO_NEXT(dp)) {          /* dp != NULL iff k lastdate */
      for (i = 0; i reqs[i] != 0)
          printf(outf, "%ut%dt%lut%lut%.0fn", k, i, dp->reqs[i],
                 dp->pages[i], dp->bytes[i]);
      }
    }
{% endcodeblock %}    


### HTTP Item Summaries 

The next section contains a wealth of information. It is structured into four subsections, each identified by the first character of the line. In this section, expect the first character to be an ASCII integer ranging from one to five: 

 -  1: URL
 -  2: ???
 -  3: Referer
 -  4: User Agent
 -  5: IP Address 

For each line, there are a number columns separated by tabs. Important columns are: 

 -  Type (Integer, range 0-4)
 -  Count (Integer)
 -  Successes (Integer)
 -  Redirects (Integer)
 -  Errors (Integer)
 -  Last time seen (Date)
 -  ??? (possibly a date)
 -  ??? (possibly a date)
 -  First time seen (Date)
 -  ??? (possibly a date)
 -  ??? (possibly a date)
 -  Bytes transferred (Integer)
 -  Name (String)

{% codeblock %}
    TYPE   COUNT  SUCC    REDIR   ERRORS    LAST DATE      ???     ???    FIRST DATE?      ???     ???       BYTES   NAME
    |        |      |       |       |           |           |       |          |            |       |          |      |
    V        V      V       V       V           V           V       V          V            V       V          V      V
    1       100     75     10       15      12345678        0       0       12345678        0       0       123456  /index.html
    3       100     75     10       15      12345678        0       0       12345678        0       0       123456  http://www.google.com?q=lolcats
    4       100     75     10       15      12345678        0       0       12345678        0       0       123456  Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0;)
    5       100     75     10       15      12345678        0       0       12345678        0       0       123456  127.0.0.1
{% endcodeblock %}

The following code generates the item summaries: 

{% codeblock lang:c %}
    /* src/anlghea3.h line 581 */
    /* Counts then dates collected about each item, and then other floor/sort
       criteria: order otherwise insignificant. See also methodname in globals.c
       and cache_records in cache.c. */
    enum {REQUESTS, REQUESTS7, PAGES, PAGES7, REDIR, REDIR7, FAIL, FAIL7, SUCCDATE,
          REDIRDATE, FAILDATE, SUCCFIRSTD, REDIRFIRSTD, FAILFIRSTD, BYTES, BYTES7,
          ALPHABETICAL, RANDOM, METHOD_NUMBER};
    
    /* src/cache.c line 83 */
      /* output the items */
      for (i = 0; i own != NULL && (p->own->data[data2cols[i][REQUESTS]] != 0 ||
    			     p->own->data[data2cols[i][FAIL]] != 0 ||
    			     p->own->data[data2cols[i][REDIR]] != 0)) {
    	fprintf(outf, "%dt", i);
    	for (j = 0; j own->data[data2cols[i][cache_records[j]]]);
    	fprintf(outf, "%.0ft%sn", p->own->bytes, p->name);
          }
        }
      }
{% endcodeblock %}


### More Summaries 

I do not have a good understanding of the next section. Each line begins with the character 'z'. Each line has six tab-separated columns, and represents some data identified by an integer index in column two. Based on variable names in the code, the columns are probably: 

 -  z (Character)
 -  Index (Integer)
 -  Requests (Integer)
 -  Pages (Integer)
 -  Last Requested Date (Date)
 -  Bytes Transferred (Date) 

I conjecture the items described by each row are time periods because there is is a separate column for both requests and pages. I do not know the length of time for each period.

Note, Analog does not print all entries it processes. It only records entries that fall within a given range (perhaps the top *X*). 

{% codeblock %}
    KEY   INDEX     REQS    PAGES    DATE           BYTES
    |       |        |       |        |             |
    V       V        V       V        V             V
    z       0       12345   1234    12345678        1
    z       1       123     1       12345678        1234
{% endcodeblock %}

The following code generates the summary information: 

{% codeblock lang:c %}
    /* src/cache.c line 97 */
      /* output the arraydata. For historical reasons, these all differ slightly */
      /* the sizes */
      for (i = 0, done = FALSE; !done; i%2B%2B) {
        if (arraydata[REP_SIZE - FIRST_ARRAYREP][i].reqs > 0)
          fprintf(outf, "zt%dt%lut%lut%lut%.0fn", i,
    	      arraydata[REP_SIZE - FIRST_ARRAYREP][i].reqs,
    	      arraydata[REP_SIZE - FIRST_ARRAYREP][i].pages,
    	      arraydata[REP_SIZE - FIRST_ARRAYREP][i].lastdate,
    	      arraydata[REP_SIZE - FIRST_ARRAYREP][i].bytes);
        if (arraydata[REP_SIZE - FIRST_ARRAYREP][i].threshold 
{% endcodeblock %}    

    
### Status Codes

The next section records statistics for response status codes.  Each 
line begins with the character 'c', and contains four tab-separated 
columns.  The columns are:

 -  c (Character)
 -  Status Code (Integer)
 -  Count (Integer)
 -  Last Encountered (Date)

{% codeblock %}
    KEY    STATUS   COUNT   DATE
    |        |       |       |
    V        V       V       V
    c       200     123456  12345678
    c       206     123     12345678
    c       301     123     12345678
    c       302     1234    12345678
    c       304     12345   12345678
    c       400     12      12345678
    c       401     12      12345678
    c       403     1       12345678
    c       404     1234    12345678
    c       405     12      12345678
    c       500     1       12345678
{% endcodeblock %}

The following code generates the status summary: 

{% codeblock lang:c %}
    /* src/cache.c line 110 */
      /* the status codes */
      for (i = 0, done = FALSE; !done; i%2B%2B) {
        if (arraydata[REP_CODE - FIRST_ARRAYREP][i].reqs > 0)
          fprintf(outf, "ct%ut%lut%lun",
    	      (unsigned int)(arraydata[REP_CODE - FIRST_ARRAYREP][i].threshold),
    	      arraydata[REP_CODE - FIRST_ARRAYREP][i].reqs,
    	      arraydata[REP_CODE - FIRST_ARRAYREP][i].lastdate);
        if (arraydata[REP_CODE - FIRST_ARRAYREP][i].threshold 
{% endcodeblock %}   
 

### Processing Times

The next section probably contains information about how long it took 
to process various requests at various times.  I do not have sample data
for this section.  Each line begins with the character 'p' and has seven 
tab-separated columns. 

{% codeblock %}    
    p       ???     ???     ???      ???    ???   ???
{% endcodeblock %}

The following code generates the processing time summary: 
    
{% codeblock lang:c %}
        /* src/cache.c line 121 */
          /* the processing times */
          for (i = 0, done = FALSE; !done; i%2B%2B) {
            if (arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].reqs > 0)
              fprintf(outf, "Pt%lut%lut%lut%lut%.0fn",
        	      (arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].threshold 
{% endcodeblock %}

Analog Date Decoder <a id="decoder"></a>
--------------------------------------

The Analog tool tracks dates in an uncommon format: minutes since the Unix epoch.
The following C program accepts one command line parameter and prints a human readable representation of the date.

{% codeblock lang:c %}        
    /***             analog 6.0             http://www.analog.cx/             ***/
    /*** This program is copyright (c) Stephen R. E. Turner 1995 - 2004 except as
     *** stated otherwise.
     ***
     *** This program is free software. You can redistribute it and/or modify it
     *** under the terms of version 2 of the GNU General Public License, which you
     *** should have received with it.
     ***
     *** This program is distributed in the hope that it will be useful, but
     *** without any warranty, expressed or implied.   ***/
    
    /*** This is a date decoding program for the Analog 6.0 date format ***/
    /*** Hacked together by Willi Ballenthin  ***/
    
    #include &lt;stdio.h&gt;
    #include &lt;stdlib.h&gt;
    
    typedef unsigned int datecode_t;
    unsigned int daysbefore[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273,
    			       304, 334};  /* in non-leap year */
    unsigned int monthlength[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,
    				31};
    
    /* Date conversion functions. See dates.c on the representation of dates. */
    #define FEB (1)
    #define DEC (11)
    #define IS_LEAPYEAR(y) ((y) % 4 == 0) /* This is not Year 2100 compatible but
    					 is Year 2000 compatible! */
    #undef MAX
    #define MAX(a, b) (((a) > (b))?(a):(b))
    #undef MIN
    #define MIN(a, b) (((a)  1/1/69 */
      *year = 1969 %2B 4 * (code / 1461);
      code %= 1461;
      *year %2B= MIN(code / 365, 3); /* no leap days for a while after 1/1/69! */
      if (code == 1460) {
        *month = DEC;
        *day = 31;
      }
      else {
        code %= 365;    /* so 0 -> 1/Jan, any year */
        for (*month = DEC;
    	 daysbefore[*month] %2B (IS_LEAPYEAR(*year) && *month > FEB) > code;
    	 (*month)--)
          ;   /* run to right month */
        *day = code - daysbefore[*month] %2B 1 -
          (IS_LEAPYEAR(*year) && *month > FEB);
      }
    }
    
    int main(int argc, char **argv) {
      int y, m, d, h, mi, s;
      int input = atoi(argv[1]);
    
      if (argc < 2) {
        printf("%s requires one integer parameter\n", argv[0]);
        return -1;
      }
    
      s = 0;
      mi = input % 60;
      h = (input % 1440) / 60;
    
      code2date(input / 1440, &d, &m, &y);
      m++;
    
      printf("%d-%d-%dT%d:%d:%d\n", y, m, d, h, mi, s);
    }
{% endcodeblock %}