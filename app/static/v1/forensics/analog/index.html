<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" /> 
<link href="/css/bootstrap-1.1.1.min.css" type="text/css" rel="stylesheet" />
<link href="/css/prettify.css" type="text/css" rel="stylesheet" />
<link href="/css/prettify_desert.css" type="text/css" rel="stylesheet" />
<link href="/css/base.css" type="text/css" rel="stylesheet" />
<title>Analog cache forensics</title>
<script type="text/javascript" src="/js/prettify/prettify.js"></script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-23141359-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</head>
<body onload="prettyPrint()">
<div class="content">

  <h1>Analog cache forensics</h1>

<a href="http://www.analog.cx">Analog</a> is a logfile analyzer.  
Its website bills the tool as "the most popular logfile analyzer in the world".
This tool reads web server logs and produces nice reports with 
graphs and other diagrams to give you a warm fuzzy feeling of productivity.
<br /><br />
Recently I performed forensics on a web server with few surviving logs.
Although access and error logs were not available, I used the cache
file generated by Analog to identify successful SQL injection attacks.
I wasn't able to find much documentation on the Analog cache file, so
I've published some here.
<br /><br />
Because Analog periodically generates reports across millions of messages,
the author developed a caching system to speed up report generation.
The cache file is meant to be opaque, but this has never stopped the 
forensicator in me. This cache file is a plain text file that is easily parsed.
Generally, Analog tracks information about a number of items. 
Analog tracks at least the following items:
<ul>
	<li>URLs requested</li>
	<li>Referers</li>
	<li>User Agents</li>
	<li>IP addresses</li>
</ul>
For each of these items, Analog tracks at least the following data:
<ul>
	<li>first seen date</li>
	<li>last seen date</li>
	<li>request count</li>
	<li>successful requests with item</li>
	<li>failed requests with item</li>
	<li>redirected requests with item</li>
	<li>bytes transferred with item</li>
</ul>
As far as I can tell, Analog processes dates as they are generated by
the web server.  For example, if Apache generates log entries as GMT-0400, 
Analog will process the local time of the server.  When storing dates, 
Analog uses a somewhat non-standard format: minutes since the epoch.   
<br /><br />
I will first include an <a href="#example">example</a> Analog cache file as a reference so you know what I'm talking about.
I will next describe the Analog 6.0 cache <a href="#format">file format</a> to the best of my
understanding.  Finally, I will also provide a <a href="#decoder">program to decode</a> the date format
used by Analog. 



<h2 id="example">Example Analog 6.0 Cache File</h2>
<pre style="width:1350px"><b>
CACHE type 5 produced by analog 6.0/Unix. Do not modify or delete!
T       0       0       123456  12345   1234    1234    1234567890
D       12345678        12345678
12345   123     1       0       12345
12345   124     1       0       12345
12345   125     1       0       12345
1       100     75     10       15      12345678        0       0       12345678        0       0       123456  /index.html
3       100     75     10       15      12345678        0       0       12345678        0       0       123456  http://www.google.com?q=lolcats
4       100     75     10       15      12345678        0       0       12345678        0       0       123456  Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0;)
5       100     75     10       15      12345678        0       0       12345678        0       0       123456  127.0.0.1
z       0       12345   1234    12345678        1
z       1       123     1       12345678        1234
c       200     123456  12345678
c       206     123     12345678
c       301     123     12345678
c       302     1234    12345678
c       304     12345   12345678
c       400     12      12345678
c       401     12      12345678
c       403     1       12345678
c       404     1234    12345678
c       405     12      12345678
c       500     1       12345678
p       ???     ???     ???      ???    ???   ???
</b></pre>


<h2 id="format">Analog 6.0 Cache Format</h2>

<h3>Header</h3>
The first line of the file will be the header: <br />
<pre><b>
CACHE type 5 produced by analog 6.0/Unix. Do not modify or delete!
</b>
</pre>
The following code generates the header: <br />
<pre class="prettyprint lang-c">
/* src/cache.c line 61 */
fprintf(outf,
        "CACHE type 5 produced by analog %s. Do not modify or delete!\n",
        VERSION);
</pre>

<h3>Summary</h3>
The second line contains a summary of all requests processed by Analog. 
The first character of the line will be the character 'T'.<br />
<pre>
KEY   UNKNOWN  INFO   SUCCESSES PAGES REDIRECTS FAIL     BYTES
|       |       |         |       |      |       |         |
V       V       V         V       V      V       V         V<b>
T       0       0       123456  12345   1234    1234    1234567890
</b></pre>
The following code generates the summary: <br />
<pre class="prettyprint lang-c">
/* src/cache.c line 65 */
fprintf(outf, "T\t%lu\t%lu\t%lu\t%lu\t%lu\t%lu\t%.0f\n",
        data[LOGDATA_UNKNOWN], data[LOGDATA_INFO], data[LOGDATA_SUCC],
        data[LOGDATA_PAGES], data[LOGDATA_REDIR], data[LOGDATA_FAIL], bys);
</pre>

<h3>Date Information</h3>
The next lines contain a summary of date information.  The first
line specifies the time period tracked by Analog.  This line will begin with  
the character 'D', and will have three tab-separated columns.  The columns are:
<ul>
  <li>D (Character)</li>
  <li>First Time (Date)</li>
  <li>Last Time (Date)</li>
</ul>
The following lines describe the activity over time. I do not have a good understanding
of the activity vs. time section.  Each line has five tab-separated columns.  The 
columns may be:
<ul>
  <li>??? (Large Integer)</li>
  <li>Index (Integer)</li>
  <li>Requests (Integer)</li>
  <li>Pages (Integer)</li>
  <li>Bytes Transferred (Integer)</li>
</ul>
<pre>KEY     FIRSTTIME       LASTTIME
|          |               |
V          V               V<b>
D       12345678        12345678
</b>
DATE?  INDEX  REQS    PAGES     BYTES    
|        |      |       |         |
V        V      V       V         V<b>
12345   123     1       0       12345
12345   124     1       0       12345
12345   125     1       0       12345
</b></pre>
The following code generates the date information: <br />
<pre class="prettyprint lang-c">
/* src/cache.c line 70 */
if (dman->firsttime == LAST_TIME && dman->lasttime == FIRST_TIME)
  fprintf(outf, "D\t%lu\t%lu\n", dman->lasttime, dman->firsttime);
else
  fprintf(outf, "D\t%lu\t%lu\n", dman->firsttime, dman->lasttime);
for (k = dman->firstdate, dp = dman->firstdp; dp != NULL;
     k++, TO_NEXT(dp)) {          /* dp != NULL iff k <= dman->lastdate */
  for (i = 0; i < 288; i++) {
    if (dp->reqs[i] != 0)
      printf(outf, "%u\t%d\t%lu\t%lu\t%.0f\n", k, i, dp->reqs[i],
             dp->pages[i], dp->bytes[i]);
  }
}
</pre>

<h3>HTTP Item Summaries</h3>
The next section contains a wealth of information. It is structured into 
four subsections, each identified by the first character of the line. In 
this section, expect the first character to be an ASCII integer ranging from
one to four:
<ul>
	<li>1: URL</li>
	<li>2: ???</li>
	<li>3: Referer</li>
	<li>4: User Agent</li>
	<li>5: IP Address</li>
</ul>

For each line, there are a number columns separated by tabs. Important columns 
are: 
<ul>
  <li>Type (Integer, range 0-4)</li>
  <li>Count (Integer)</li>
  <li>Successes (Integer)</li>
  <li>Redirects (Integer)</li>
  <li>Errors (Integer)</li>
  <li>Last time seen (Date)</li>
  <li>??? (possibly a date)</li>
  <li>??? (possibly a date)</li>
  <li>First time seen (Date)</li>
  <li>??? (possibly a date)</li>
  <li>??? (possibly a date)</li>
  <li>Bytes transferred (Integer)</li>
  <li>Name (String)</li>
</ul>

<pre style="width:1350px">
TYPE   COUNT  SUCC    REDIR   ERRORS    LAST DATE      ???     ???    FIRST DATE?      ???     ???       BYTES   NAME
|        |      |       |       |           |           |       |          |            |       |          |      |
V        V      V       V       V           V           V       V          V            V       V          V      V<b>
1       100     75     10       15      12345678        0       0       12345678        0       0       123456  /index.html
3       100     75     10       15      12345678        0       0       12345678        0       0       123456  http://www.google.com?q=lolcats
4       100     75     10       15      12345678        0       0       12345678        0       0       123456  Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0;)
5       100     75     10       15      12345678        0       0       12345678        0       0       123456  127.0.0.1
</b></pre>

The following code generates the item summaries: <br />
<pre class="prettyprint lang-c">
/* src/anlghea3.h line 581 */
/* Counts then dates collected about each item, and then other floor/sort
   criteria: order otherwise insignificant. See also methodname in globals.c
   and cache_records in cache.c. */
enum {REQUESTS, REQUESTS7, PAGES, PAGES7, REDIR, REDIR7, FAIL, FAIL7, SUCCDATE,
      REDIRDATE, FAILDATE, SUCCFIRSTD, REDIRFIRSTD, FAILFIRSTD, BYTES, BYTES7,
      ALPHABETICAL, RANDOM, METHOD_NUMBER};

/* src/cache.c line 83 */
  /* output the items */
  for (i = 0; i < ITEM_NUMBER; i++) { /* 1 = url, 2 = ??? ,3 = referer, 4 = user agent, 5 = ip */
    for (p = gooditems[i]; p != NULL; TO_NEXT(p)) {
      if (p->own != NULL && (p->own->data[data2cols[i][REQUESTS]] != 0 ||
			     p->own->data[data2cols[i][FAIL]] != 0 ||
			     p->own->data[data2cols[i][REDIR]] != 0)) {
	fprintf(outf, "%d\t", i);
	for (j = 0; j < V5_DATA_NUMBER; j++)
	  fprintf(outf, "%lu\t", p->own->data[data2cols[i][cache_records[j]]]);
	fprintf(outf, "%.0f\t%s\n", p->own->bytes, p->name);
      }
    }
  }
</pre>


<h3>More Summaries</h3>
I do not have a good understanding of the next section. Each line begins with
the character 'z'.  Each line has six tab-separated columns, and represents
some data identified by an integer index in column two.  Based on variable names
in the code, the columns are probably:

<ul>
  <li>z (Character)</li>
  <li>Index (Integer)</li>
  <li>Requests (Integer)</li>
  <li>Pages (Integer)</li>
  <li>Last Requested Date (Date)</li>
  <li>Bytes Transferred (Date)</li>
</ul>

I conjecture the items described by each row are time periods because there is
is a separate column for both requests and pages.  I do not know the length of
time for each period.<br /><br />

Also, Analog does not print all entries it processes. It only records
entries that fall within a given range (perhaps the top <i>X</i>).

<pre>
KEY   INDEX     REQS    PAGES    DATE           BYTES
|       |        |       |        |             |
V       V        V       V        V             V<b>
z       0       12345   1234    12345678        1
z       1       123     1       12345678        1234
</b></pre>


The following code generates the summary information: <br />
<pre class="prettyprint lang-c">
  /* src/cache.c line 97 */
  /* output the arraydata. For historical reasons, these all differ slightly */
  /* the sizes */
  for (i = 0, done = FALSE; !done; i++) {
    if (arraydata[REP_SIZE - FIRST_ARRAYREP][i].reqs > 0)
      fprintf(outf, "z\t%d\t%lu\t%lu\t%lu\t%.0f\n", i,
	      arraydata[REP_SIZE - FIRST_ARRAYREP][i].reqs,
	      arraydata[REP_SIZE - FIRST_ARRAYREP][i].pages,
	      arraydata[REP_SIZE - FIRST_ARRAYREP][i].lastdate,
	      arraydata[REP_SIZE - FIRST_ARRAYREP][i].bytes);
    if (arraydata[REP_SIZE - FIRST_ARRAYREP][i].threshold < -0.5)
      done = TRUE;
  }
</pre>


<h3>Status Codes</h3>
The next section records statistics for response status codes.  Each 
line begins with the character 'c', and contains four tab-separated 
columns.  The columns are:
<ul>
  <li>c (Character)</li>
  <li>Status Code (Integer)</li>
  <li>Count (Integer)</li>
  <li>Last Encountered (Date)</li>
</ul>

<pre>
KEY    STATUS   COUNT   DATE
|        |       |       |
V        V       V       V<b>
c       200     123456  12345678
c       206     123     12345678
c       301     123     12345678
c       302     1234    12345678
c       304     12345   12345678
c       400     12      12345678
c       401     12      12345678
c       403     1       12345678
c       404     1234    12345678
c       405     12      12345678
c       500     1       12345678
</b></pre>

The following code generates the status summary: <br />
<pre class="prettyprint lang-c">
  /* src/cache.c line 110 */
  /* the status codes */
  for (i = 0, done = FALSE; !done; i++) {
    if (arraydata[REP_CODE - FIRST_ARRAYREP][i].reqs > 0)
      fprintf(outf, "c\t%u\t%lu\t%lu\n",
	      (unsigned int)(arraydata[REP_CODE - FIRST_ARRAYREP][i].threshold),
	      arraydata[REP_CODE - FIRST_ARRAYREP][i].reqs,
	      arraydata[REP_CODE - FIRST_ARRAYREP][i].lastdate);
    if (arraydata[REP_CODE - FIRST_ARRAYREP][i].threshold < -0.5)
      done = TRUE;
  }
</pre>

<h3>Processing Times</h3>
The next section probably contains information about how long it took 
to process various requests at various times.  I do not have sample data
for this section.  Each line begins with the character 'p' and has seven 
tab-separated columns. 

<pre><b>
p       ???     ???     ???      ???    ???   ???
</pre></b>

The following code generates the processing time summary: <br />
<pre class="prettyprint lang-c">
  /* src/cache.c line 121 */
  /* the processing times */
  for (i = 0, done = FALSE; !done; i++) {
    if (arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].reqs > 0)
      fprintf(outf, "P\t%lu\t%lu\t%lu\t%lu\t%.0f\n",
	      (arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].threshold < -0.5)?
	      ((unsigned long)(arraydata[REP_PROCTIME - FIRST_ARRAYREP][i - 1].threshold) + 1):
	      ((unsigned long)(arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].threshold)),
	      arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].reqs,
	      arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].pages,
	      arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].lastdate,
	      arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].bytes);
    if (arraydata[REP_PROCTIME - FIRST_ARRAYREP][i].threshold < -0.5)
      done = TRUE;
  }
</pre>

<h2 id="decoder">Analog Date Decoder</h2>
The Analog tool tracks dates in an uncommon format: minutes since the Unix epoch.
The following C program accepts one command line parameter and prints a human readable representation of the date.

<pre class="prettyprint lang-c">

/***             analog 6.0             http://www.analog.cx/             ***/
/*** This program is copyright (c) Stephen R. E. Turner 1995 - 2004 except as
 *** stated otherwise.
 ***
 *** This program is free software. You can redistribute it and/or modify it
 *** under the terms of version 2 of the GNU General Public License, which you
 *** should have received with it.
 ***
 *** This program is distributed in the hope that it will be useful, but
 *** without any warranty, expressed or implied.   ***/

/*** This is a date decoding program for the Analog 6.0 date format ***/
/*** Hacked together by Willi Ballenthin &lt;willi.ballenthin@gmail.com&gt; ***/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef unsigned int datecode_t;
unsigned int daysbefore[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273,
			       304, 334};  /* in non-leap year */
unsigned int monthlength[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30,
				31};

/* Date conversion functions. See dates.c on the representation of dates. */
#define FEB (1)
#define DEC (11)
#define IS_LEAPYEAR(y) ((y) % 4 == 0) /* This is not Year 2100 compatible but
					 is Year 2000 compatible! */
#undef MAX
#define MAX(a, b) (((a) > (b))?(a):(b))
#undef MIN
#define MIN(a, b) (((a) < (b))?(a):(b))

void code2date(datecode_t code, unsigned int *day, unsigned int *month, unsigned int *year) {
  code += 364;    /* so 0 -> 1/1/69 */
  *year = 1969 + 4 * (code / 1461);
  code %= 1461;
  *year += MIN(code / 365, 3); /* no leap days for a while after 1/1/69! */
  if (code == 1460) {
    *month = DEC;
    *day = 31;
  }
  else {
    code %= 365;    /* so 0 -> 1/Jan, any year */
    for (*month = DEC;
	 daysbefore[*month] + (IS_LEAPYEAR(*year) && *month > FEB) > code;
	 (*month)--)
      ;   /* run to right month */
    *day = code - daysbefore[*month] + 1 -
      (IS_LEAPYEAR(*year) && *month > FEB);
  }
}

int main(int argc, char **argv) {
  int y, m, d, h, mi, s;
  int input = atoi(argv[1]);

  if (argc < 2) {
    printf("%s requires one integer parameter\n", argv[0]);
    return -1;
  }

  s = 0;
  mi = input % 60;
  h = (input % 1440) / 60;

  code2date(input / 1440, &d, &m, &y);
  m++;

  printf("%d-%d-%dT%d:%d:%d\n", y, m, d, h, mi, s);
}

</pre>

</div>
</body>
</html>

