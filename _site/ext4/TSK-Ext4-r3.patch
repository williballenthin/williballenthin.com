diff -Naur sleuthkit-3.2.1-orig/tools/sorter/sorter.base sleuthkit-3.2.1-ext4/tools/sorter/sorter.base
--- sleuthkit-3.2.1-orig/tools/sorter/sorter.base	2011-06-05 21:32:48.694440887 -0400
+++ sleuthkit-3.2.1-ext4/tools/sorter/sorter.base	2011-06-05 21:19:35.184441227 -0400
@@ -1418,9 +1418,11 @@
     }
     elsif (($FSTYPE eq "-f linux-ext2")
         || ($FSTYPE eq "-f linux-ext3")
+        || ($FSTYPE eq "-f linux-ext4")
         || ($FSTYPE eq "-f ext")
         || ($FSTYPE eq "-f ext2")
-        || ($FSTYPE eq "-f ext3"))
+        || ($FSTYPE eq "-f ext3")
+	|| ($FSTYPE eq "-f ext4")))
     {
         $PLATFORM = "linux";
     }
diff -Naur sleuthkit-3.2.1-orig/tools/srchtools/sigfind.cpp sleuthkit-3.2.1-ext4/tools/srchtools/sigfind.cpp
--- sleuthkit-3.2.1-orig/tools/srchtools/sigfind.cpp	2011-06-05 21:32:48.694440887 -0400
+++ sleuthkit-3.2.1-ext4/tools/srchtools/sigfind.cpp	2011-06-05 21:19:35.184441227 -0400
@@ -33,7 +33,7 @@
     fprintf(stderr,
             "\t-t template: The name of a data structure template:\n");
     fprintf(stderr,
-            "\t\tdospart, ext2, ext3, fat, hfs, hfs+, ntfs, ufs1, ufs2\n");
+            "\t\tdospart, ext2, ext3, ext4, fat, hfs, hfs+, ntfs, ufs1, ufs2\n");
     exit(1);
 }
 
@@ -90,7 +90,8 @@
 
         case 't':
             if ((strcmp(optarg, "ext2") == 0) ||
-                (strcmp(optarg, "ext3") == 0)) {
+                (strcmp(optarg, "ext3") == 0) ||
+		(strcmp(optarg, "ext4") == 0)) {
                 lit_end = 1;
                 sig[0] = 0x53;
                 sig[1] = 0xef;
diff -Naur sleuthkit-3.2.1-orig/tsk3/fs/ext2fs.c sleuthkit-3.2.1-ext4/tsk3/fs/ext2fs.c
--- sleuthkit-3.2.1-orig/tsk3/fs/ext2fs.c	2011-06-05 21:32:48.744440887 -0400
+++ sleuthkit-3.2.1-ext4/tsk3/fs/ext2fs.c	2011-08-21 12:53:06.188495242 -0400
@@ -14,7 +14,7 @@
 
 /**
  *\file ext2fs.c
- * Contains the internal TSK ext2/ext3 file system functions.
+ * Contains the internal TSK ext2/ext3/ext4 file system functions.
  */
 
 /* TCT 
@@ -295,8 +295,10 @@
 
     /* Allocate the buffer or return if already loaded */
     if (ext2fs->dino_buf == NULL) {
+	unsigned int size = ext2fs->inode_size > sizeof(ext2fs_inode) ?
+		ext2fs->inode_size : sizeof(ext2fs_inode);
         if ((ext2fs->dino_buf =
-                (ext2fs_inode *) tsk_malloc(ext2fs->inode_size)) == NULL) {
+                (ext2fs_inode *) tsk_malloc(size)) == NULL) {
             return 1;
         }
     }
@@ -375,7 +377,7 @@
     ext2fs_sb *sb = ext2fs->fs;
     EXT2_GRPNUM_T grp_num;
     TSK_INUM_T ibase = 0;
-    TSK_DADDR_T *addr_ptr;
+    
 
     if (ext2fs->dino_buf == NULL) {
         tsk_error_reset();
@@ -477,10 +479,17 @@
     fs_meta->mtime = tsk_getu32(fs->endian, in->i_mtime);
     fs_meta->atime = tsk_getu32(fs->endian, in->i_atime);
     fs_meta->ctime = tsk_getu32(fs->endian, in->i_ctime);
-    fs_meta->crtime = 0;
     fs_meta->time2.ext2.dtime = tsk_getu32(fs->endian, in->i_dtime);
-    fs_meta->mtime_nano = fs_meta->atime_nano = fs_meta->ctime_nano =
-        fs_meta->crtime_nano = 0;
+    if (fs->ftype == TSK_FS_TYPE_EXT4) {
+      fs_meta->crtime = tsk_getu32(fs->endian, in->i_crtime);
+    }
+    
+    fs_meta->mtime_nano = tsk_getu32(fs->endian, in->i_mtime_extra) >> 2;
+    fs_meta->atime_nano = tsk_getu32(fs->endian, in->i_atime_extra) >> 2;
+    fs_meta->ctime_nano = tsk_getu32(fs->endian, in->i_ctime_extra) >> 2;
+    if (fs->ftype == TSK_FS_TYPE_EXT4) {
+      fs_meta->crtime_nano = tsk_getu32(fs->endian, in->i_crtime_extra) >> 2;
+    }
     fs_meta->time2.ext2.dtime_nano = 0;
     fs_meta->seq = 0;
 
@@ -497,91 +506,104 @@
         }
     }
 
-    addr_ptr = (TSK_DADDR_T *) fs_meta->content_ptr;
-    for (i = 0; i < EXT2FS_NDADDR + EXT2FS_NIADDR; i++)
-        addr_ptr[i] = tsk_gets32(fs->endian, in->i_block[i]);
-
-    /* set the link string 
-     * the size check prevents us from trying to allocate a huge amount of
-     * memory for a bad inode value
-     */
-    if ((fs_meta->type == TSK_FS_META_TYPE_LNK)
-        && (fs_meta->size < EXT2FS_MAXPATHLEN) && (fs_meta->size >= 0)) {
-        unsigned int count = 0;
-        int i;
-
-        if ((fs_meta->link =
-                tsk_malloc((size_t) (fs_meta->size + 1))) == NULL)
-            return 1;
-
-        /* it is located directly in the pointers */
-        if (fs_meta->size < 4 * (EXT2FS_NDADDR + EXT2FS_NIADDR)) {
-            unsigned int j;
-
-            for (i = 0; i < (EXT2FS_NDADDR + EXT2FS_NIADDR) &&
-                count < fs_meta->size; i++) {
-                char *a_ptr = (char *) &in->i_block[i];
-                for (j = 0; j < 4 && count < fs_meta->size; j++) {
-                    fs_meta->link[count++] = a_ptr[j];
-                }
-            }
-            fs_meta->link[count] = '\0';
-
-            /* clear the content pointer data to avoid the prog from reading them */
-            memset(fs_meta->content_ptr, 0, fs_meta->content_len);
+    if (tsk_getu32(fs->endian, in->i_flags) & EXT2_IN_EXTENTS) {
+        uint32_t *addr_ptr;
+        fs_meta->content_type = TSK_FS_META_CONTENT_TYPE_UNIX_EXTENT;
+        /* NOTE TSK_DADDR_T != uint32_t, so lets make sure we use uint32_t */        
+        addr_ptr = (uint32_t *)fs_meta->content_ptr;
+        for (i = 0; i < EXT2FS_NDADDR + EXT2FS_NIADDR; i++) {
+            addr_ptr[i] = tsk_gets32(fs->endian, in->i_block[i]);;
         }
+    }
+    else {
+        TSK_DADDR_T *addr_ptr;
+        fs_meta->content_type = TSK_FS_META_CONTENT_TYPE_UNIX_INDIRECT;
+        addr_ptr = (TSK_DADDR_T *)fs_meta->content_ptr;
+        for (i = 0; i < EXT2FS_NDADDR + EXT2FS_NIADDR; i++)
+            addr_ptr[i] = tsk_gets32(fs->endian, in->i_block[i]);
+
+        /* set the link string 
+        * the size check prevents us from trying to allocate a huge amount of
+        * memory for a bad inode value
+        */
+        if ((fs_meta->type == TSK_FS_META_TYPE_LNK)
+            && (fs_meta->size < EXT2FS_MAXPATHLEN) && (fs_meta->size >= 0)) {
+            unsigned int count = 0;
+            int i;
 
-        /* it is in blocks */
-        else {
-            TSK_FS_INFO *fs = (TSK_FS_INFO *) & ext2fs->fs_info;
-            char *data_buf;
-            char *a_ptr = fs_meta->link;
-            TSK_DADDR_T *addr_ptr = fs_meta->content_ptr;;
-
-            if ((data_buf = tsk_malloc(fs->block_size)) == NULL)
+            if ((fs_meta->link =
+                    tsk_malloc((size_t) (fs_meta->size + 1))) == NULL)
                 return 1;
 
-            /* we only need to do the direct blocks due to the limit 
-             * on path length */
-            for (i = 0; i < EXT2FS_NDADDR && count < fs_meta->size; i++) {
-                ssize_t cnt;
-
-                int read_count =
-                    (fs_meta->size - count <
-                    fs->block_size) ? (int) (fs_meta->size -
-                    count) : (int) (fs->block_size);
-
-                cnt = tsk_fs_read_block(fs,
-                    addr_ptr[i], data_buf, fs->block_size);
-
-                if (cnt != fs->block_size) {
-                    if (cnt >= 0) {
-                        tsk_error_reset();
-                        tsk_errno = TSK_ERR_FS_READ;
+            /* it is located directly in the pointers */
+            if (fs_meta->size < 4 * (EXT2FS_NDADDR + EXT2FS_NIADDR)) {
+                unsigned int j;
+
+                for (i = 0; i < (EXT2FS_NDADDR + EXT2FS_NIADDR) &&
+                    count < fs_meta->size; i++) {
+                    char *a_ptr = (char *) &in->i_block[i];
+                    for (j = 0; j < 4 && count < fs_meta->size; j++) {
+                        fs_meta->link[count++] = a_ptr[j];
                     }
-                    snprintf(tsk_errstr2, TSK_ERRSTR_L,
-                        "ext2fs_dinode_copy: symlink destination from %"
-                        PRIuDADDR, addr_ptr[i]);
-                    free(data_buf);
+                }
+                fs_meta->link[count] = '\0';
+
+                /* clear the content pointer data to avoid the prog from reading them */
+                memset(fs_meta->content_ptr, 0, fs_meta->content_len);
+            }
+
+            /* it is in blocks */
+            else {
+                TSK_FS_INFO *fs = (TSK_FS_INFO *) & ext2fs->fs_info;
+                char *data_buf;
+                char *a_ptr = fs_meta->link;
+                TSK_DADDR_T *addr_ptr = (TSK_DADDR_T *)fs_meta->content_ptr;
+
+                if ((data_buf = tsk_malloc(fs->block_size)) == NULL)
                     return 1;
+
+                /* we only need to do the direct blocks due to the limit 
+                * on path length */
+                for (i = 0; i < EXT2FS_NDADDR && count < fs_meta->size; i++) {
+                    ssize_t cnt;
+
+                    int read_count =
+                        (fs_meta->size - count <
+                        fs->block_size) ? (int) (fs_meta->size -
+                        count) : (int) (fs->block_size);
+
+                    cnt = tsk_fs_read_block(fs,
+                        addr_ptr[i], data_buf, fs->block_size);
+
+                    if (cnt != fs->block_size) {
+                        if (cnt >= 0) {
+                            tsk_error_reset();
+                            tsk_errno = TSK_ERR_FS_READ;
+                        }
+                        snprintf(tsk_errstr2, TSK_ERRSTR_L,
+                            "ext2fs_dinode_copy: symlink destination from %"
+                            PRIuDADDR, addr_ptr[i]);
+                        free(data_buf);
+                        return 1;
+                    }
+
+                    memcpy(a_ptr, data_buf, read_count);
+                    count += read_count;
+                    a_ptr = (char *) ((uintptr_t) a_ptr + count);
                 }
 
-                memcpy(a_ptr, data_buf, read_count);
-                count += read_count;
-                a_ptr = (char *) ((uintptr_t) a_ptr + count);
-            }
-
-            /* terminate the string */
-            *a_ptr = '\0';
-            free(data_buf);
-        }
-
-        /* Clean up name */
-        i = 0;
-        while (fs_meta->link[i] != '\0') {
-            if (TSK_IS_CNTRL(fs_meta->link[i]))
-                fs_meta->link[i] = '^';
-            i++;
+                /* terminate the string */
+                *a_ptr = '\0';
+                free(data_buf);
+            }
+
+            /* Clean up name */
+            i = 0;
+            while (fs_meta->link[i] != '\0') {
+                if (TSK_IS_CNTRL(fs_meta->link[i]))
+                    fs_meta->link[i] = '^';
+                i++;
+            }
         }
     }
 
@@ -1080,6 +1102,302 @@
 }
 
 
+/** \internal
+ * Add a single extent -- that is, a single data ran -- to the file data attribute.
+ * @return 0 on success, 1 on error.
+ */
+static TSK_OFF_T
+ext2fs_make_data_run_extent(TSK_FS_INFO * fs_info, TSK_FS_ATTR * fs_attr, 
+                            ext2fs_extent *extent)
+{
+    TSK_FS_ATTR_RUN *data_run;
+    data_run = tsk_fs_attr_run_alloc();
+    if (data_run == NULL) {
+        return 1;
+    }
+    
+    data_run->offset = tsk_getu32(fs_info->endian, extent->ee_block);
+    data_run->addr = (((uint32_t)tsk_getu16(fs_info->endian, extent->ee_start_hi)) << 16) | tsk_getu32(fs_info->endian, extent->ee_start_lo);
+    data_run->len = tsk_getu16(fs_info->endian, extent->ee_len);
+
+    // save the run
+    if (tsk_fs_attr_add_run(fs_info, fs_attr, data_run)) {
+        return 1;
+    }
+    
+    return 0;
+}
+
+
+/** \internal
+ * Given a block that contains an extent node (which starts with extent_header),
+ * walk it, and add everything encountered to the appropriate attributes.
+ * @return 0 on success, 1 on error.
+ */
+static TSK_OFF_T
+ext2fs_make_data_run_extent_index(TSK_FS_INFO *fs_info, TSK_FS_ATTR *fs_attr, 
+                                  TSK_FS_ATTR *fs_attr_extent, TSK_DADDR_T idx_block) 
+{
+    ext2fs_extent_header *header;
+    TSK_FS_ATTR_RUN* data_run;
+    uint8_t *buf;
+    ssize_t cnt;
+    unsigned int i;
+    
+    /* first, read the block specified by the parameter */
+    int fs_blocksize = fs_info->block_size;
+    if ((buf = (uint8_t *)tsk_malloc(fs_blocksize)) == NULL) {
+        return 1;
+    }
+    
+    cnt = tsk_fs_read_block(fs_info, idx_block, (char *)buf, fs_blocksize);
+    if (cnt != fs_blocksize) {
+        if (cnt >= 0) {
+            tsk_error_reset();
+            tsk_errno = TSK_ERR_FS_READ;
+        }
+        snprintf(tsk_errstr2, TSK_ERRSTR_L,
+            "ext2fs_make_data_run_extent_index: Block %" PRIuDADDR, idx_block);
+        return 1;
+    }
+    header = (ext2fs_extent_header *)buf;
+   
+    /* add it to the extent attribute */
+    if (tsk_getu16(fs_info->endian, header->eh_magic) != 0xF30A) {
+        tsk_errno = TSK_ERR_FS_INODE_COR;
+        snprintf(tsk_errstr, TSK_ERRSTR_L,
+            "ext2fs_make_data_run_extent_index: extent header magic valid incorrect!");
+        return 1;
+    }     
+    
+    data_run = tsk_fs_attr_run_alloc();
+    if (data_run == NULL) {
+        return 1;
+    }
+    data_run->addr = idx_block;
+    data_run->len = fs_blocksize;
+
+    if (tsk_fs_attr_add_run(fs_info, fs_attr_extent, data_run)) {
+        return 1;
+    }
+    
+    /* process leaf nodes */
+    if (tsk_getu16(fs_info->endian, header->eh_depth) == 0) {
+        ext2fs_extent *extents = (ext2fs_extent *)(header + 1);
+        for (i = 0; i < tsk_getu16(fs_info->endian, header->eh_entries); i++) {
+            ext2fs_extent extent = extents[i];
+            if (ext2fs_make_data_run_extent(fs_info, fs_attr, &extent)) {
+                return 1;
+            }
+        }
+    }    
+    /* recurse on interior nodes */
+    else {
+        ext2fs_extent_idx *indices = (ext2fs_extent_idx *)(header + 1);
+        for (i = 0; i < tsk_getu16(fs_info->endian, header->eh_entries); i++) {
+            ext2fs_extent_idx *index = &indices[i];
+            TSK_DADDR_T child_block = (((uint32_t)tsk_getu16(fs_info->endian, index->ei_leaf_hi)) << 16) | tsk_getu32(fs_info->endian, index->ei_leaf_lo);
+            if (ext2fs_make_data_run_extent_index(fs_info, fs_attr, fs_attr_extent, child_block)) {
+                return 1;
+            }
+        }
+    }
+   
+    free(buf);    
+    return 0;
+}
+
+/** \internal
+ * Get the number of extent blocks rooted at the given extent_header.
+ * The count does not include the extent header passed as a parameter.
+ * 
+ * @return the number of extent blocks, or -1 on error.
+ */
+static int32_t
+ext2fs_extent_tree_index_count(TSK_FS_INFO *fs_info, TSK_FS_META *fs_meta, 
+                               ext2fs_extent_header *header) {
+    int fs_blocksize = fs_info->block_size;
+    ext2fs_extent_idx *indices;
+    int count = 0;
+    uint8_t *buf;
+    int i;
+    
+    if (tsk_getu16(fs_info->endian, header->eh_magic) != 0xF30A) {
+        tsk_errno = TSK_ERR_FS_INODE_COR;
+        snprintf(tsk_errstr, TSK_ERRSTR_L,
+            "ext2fs_load_attrs: extent header magic valid incorrect!");
+        return -1;
+    }  
+    
+    if (tsk_getu16(fs_info->endian, header->eh_depth) == 0) {
+      return 0;
+    }
+    
+    if ((buf = (uint8_t *)tsk_malloc(fs_blocksize)) == NULL) {
+        return -1;
+    }
+    
+    indices = (ext2fs_extent_idx *)(header + 1);
+    for (i = 0; i < tsk_getu16(fs_info->endian, header->eh_entries); i++) {
+        ext2fs_extent_idx *index = &indices[i];
+        TSK_DADDR_T block = (((uint32_t)tsk_getu16(fs_info->endian, index->ei_leaf_hi)) << 16) | tsk_getu32(fs_info->endian, index->ei_leaf_lo);
+        ssize_t cnt = tsk_fs_read_block(fs_info, block, (char *)buf, fs_blocksize);
+        int ret;
+        
+        if (cnt != fs_blocksize) {
+            if (cnt >= 0) {
+                tsk_error_reset();
+                tsk_errno = TSK_ERR_FS_READ;
+            }
+            snprintf(tsk_errstr2, TSK_ERRSTR_L,
+                "ext2fs_extent_tree_index_count: Block %" PRIuDADDR, block);
+            return -1;
+        }
+        
+        if ((ret = ext2fs_extent_tree_index_count(fs_info, fs_meta, (ext2fs_extent_header *)buf)) < 0) {
+            return -1;
+        }
+        count += ret;
+        count++;
+    }
+    
+    free(buf);
+    return count;
+}
+
+
+/** \internal
+ * Add the data runs and extents to the file attributes.
+ *
+ * @param fs_file File system to analyze
+ * @returns 0 on success, 1 otherwise
+ */
+static uint8_t
+ext2fs_load_attrs(TSK_FS_FILE * fs_file)
+{
+    TSK_FS_META *fs_meta = fs_file->meta;
+    TSK_FS_INFO *fs_info = fs_file->fs_info;
+    TSK_OFF_T length = 0;
+    TSK_FS_ATTR *fs_attr;
+    int i;
+    
+    if (fs_meta->content_type == TSK_FS_META_CONTENT_TYPE_UNIX_EXTENT) {
+        ext2fs_extent_header *header = (ext2fs_extent_header *)fs_meta->content_ptr;
+        uint16_t num_entries = tsk_getu16(fs_info->endian, header->eh_entries);
+        uint16_t depth = tsk_getu16(fs_info->endian, header->eh_depth); 
+        
+        if (tsk_getu16(fs_info->endian, header->eh_magic) != 0xF30A) {
+            tsk_errno = TSK_ERR_FS_INODE_COR;
+            snprintf(tsk_errstr, TSK_ERRSTR_L,
+                "ext2fs_load_attrs: extent header magic valid incorrect!");
+            return TSK_COR;
+        }
+        
+        if (num_entries == 0) {
+            return 0;
+        }
+        
+        if ((fs_meta->attr != NULL)
+            && (fs_meta->attr_state == TSK_FS_META_ATTR_STUDIED)) {
+            return 0;
+        }
+        else if (fs_meta->attr_state == TSK_FS_META_ATTR_ERROR) {
+            return 1;
+        }
+        else if (fs_meta->attr != NULL) {
+            tsk_fs_attrlist_markunused(fs_meta->attr);
+        }
+        else if (fs_meta->attr == NULL) {
+            fs_meta->attr = tsk_fs_attrlist_alloc();
+        }
+        
+        if (TSK_FS_TYPE_ISEXT(fs_info->ftype) == 0) {
+            tsk_errno = TSK_ERR_FS_INODE_COR;
+            snprintf(tsk_errstr, TSK_ERRSTR_L,
+                "ext2fs_load_attr: Called with non-ExtX file system: %x",
+                fs_info->ftype);
+            return 1;
+        }        
+        
+        length = roundup(fs_meta->size, fs_info->block_size);
+
+        if ((fs_attr =
+                tsk_fs_attrlist_getnew(fs_meta->attr,
+                    TSK_FS_ATTR_NONRES)) == NULL) {
+            return 1;
+        }
+
+        if (tsk_fs_attr_set_run(fs_file, fs_attr, NULL, NULL,
+                TSK_FS_ATTR_TYPE_DEFAULT, TSK_FS_ATTR_ID_DEFAULT,
+                fs_meta->size, fs_meta->size, length, 0, 0)) {
+            return 1;
+        }
+        
+        if (depth == 0) { /* leaf node */        
+            if (num_entries > (fs_info->block_size - sizeof(ext2fs_extent_header)) / sizeof(ext2fs_extent)) {
+                tsk_errno = TSK_ERR_FS_INODE_COR;
+                snprintf(tsk_errstr, TSK_ERRSTR_L,
+                    "ext2fs_load_attr: Inode reports too many extents");
+                return 1;                
+            }    
+            
+            ext2fs_extent *extents = (ext2fs_extent *)(header + 1);
+            for (i = 0; i < num_entries; i++) {
+                ext2fs_extent extent = extents[i];
+                if (ext2fs_make_data_run_extent(fs_info, fs_attr, &extent)) {
+                    return 1;
+                }
+            }
+        }
+        else { /* interior node */
+            TSK_FS_ATTR *fs_attr_extent;
+            int32_t extent_index_size;
+            
+            if (num_entries > (fs_info->block_size - sizeof(ext2fs_extent_header)) / sizeof(ext2fs_extent_idx)) {
+                tsk_errno = TSK_ERR_FS_INODE_COR;
+                snprintf(tsk_errstr, TSK_ERRSTR_L,
+                    "ext2fs_load_attr: Inode reports too many extent indices");
+                return 1;                
+            }               
+            
+            if ((fs_attr_extent =
+                    tsk_fs_attrlist_getnew(fs_meta->attr,
+                        TSK_FS_ATTR_NONRES)) == NULL) {
+                return 1;
+            }
+            
+            extent_index_size = ext2fs_extent_tree_index_count(fs_info, fs_meta, header);
+            if (extent_index_size < 0) {
+                return 1;
+            }
+            
+            if (tsk_fs_attr_set_run(fs_file, fs_attr_extent, NULL, NULL,
+                    TSK_FS_ATTR_TYPE_UNIX_EXTENT, TSK_FS_ATTR_ID_DEFAULT,
+                    fs_info->block_size * extent_index_size,
+                    fs_info->block_size * extent_index_size,
+                    fs_info->block_size * extent_index_size,
+                        0, 0)) {
+                return 1;
+            }
+            
+            ext2fs_extent_idx *indices= (ext2fs_extent_idx *)(header + 1);
+            for (i = 0; i < num_entries; i++) {
+                ext2fs_extent_idx *index = &indices[i];
+                TSK_DADDR_T child_block = (((uint32_t)tsk_getu16(fs_info->endian, index->ei_leaf_hi)) << 16) | tsk_getu32(fs_info->endian, index->ei_leaf_lo);
+                if (ext2fs_make_data_run_extent_index(fs_info, fs_attr, fs_attr_extent, child_block)) {
+                    return 1;
+                }
+            }
+        }
+        fs_meta->attr_state = TSK_FS_META_ATTR_STUDIED;
+        
+        return 0;
+    }
+    else {
+        return tsk_fs_unix_make_data_run(fs_file);
+    }
+}
+
 
 static uint8_t
 ext2fs_fscheck(TSK_FS_INFO * fs, FILE * hFile)
@@ -1108,6 +1426,7 @@
     ext2fs_sb *sb = ext2fs->fs;
     int ibpg;
     time_t tmptime;
+    char *tmptypename;
 
 
     // clean up any error messages that are lying around
@@ -1116,8 +1435,17 @@
     tsk_fprintf(hFile, "FILE SYSTEM INFORMATION\n");
     tsk_fprintf(hFile, "--------------------------------------------\n");
 
-    tsk_fprintf(hFile, "File System Type: %s\n",
-        (fs->ftype == TSK_FS_TYPE_EXT3) ? "Ext3" : "Ext2");
+    switch(fs->ftype) {
+      case TSK_FS_TYPE_EXT3:
+        tmptypename = "Ext3";
+        break;
+      case TSK_FS_TYPE_EXT4:
+        tmptypename = "Ext4";
+        break;
+      default:
+        tmptypename = "Ext2";
+    }
+    tsk_fprintf(hFile, "File System Type: %s\n", tmptypename);
     tsk_fprintf(hFile, "Volume Name: %s\n", sb->s_volume_name);
     tsk_fprintf(hFile, "Volume ID: %" PRIx64 "%" PRIx64 "\n",
         tsk_getu64(fs->endian, &sb->s_uuid[8]), tsk_getu64(fs->endian,
@@ -1213,7 +1541,28 @@
         if (tsk_getu32(fs->endian, sb->s_feature_incompat) &
             EXT2FS_FEATURE_INCOMPAT_JOURNAL_DEV)
             tsk_fprintf(hFile, "Journal Dev");
-
+        if (tsk_getu32(fs->endian, sb->s_feature_incompat) &
+            EXT2FS_FEATURE_INCOMPAT_META_BG)
+            tsk_fprintf(hFile, "Meta Block Groups, ");
+        if (tsk_getu32(fs->endian, sb->s_feature_incompat) &
+            EXT2FS_FEATURE_INCOMPAT_EXTENTS)
+            tsk_fprintf(hFile, "Extents, ");
+        if (tsk_getu32(fs->endian, sb->s_feature_incompat) &
+            EXT2FS_FEATURE_INCOMPAT_64BIT)
+            tsk_fprintf(hFile, "64 bit FS, ");
+        if (tsk_getu32(fs->endian, sb->s_feature_incompat) &
+            EXT2FS_FEATURE_INCOMPAT_MMP)
+            tsk_fprintf(hFile, "Multiple Mount Protection, ");
+        if (tsk_getu32(fs->endian, sb->s_feature_incompat) &
+            EXT2FS_FEATURE_INCOMPAT_FLEX_BG)
+            tsk_fprintf(hFile, "Flexible Block Groups, ");
+        if (tsk_getu32(fs->endian, sb->s_feature_incompat) &
+            EXT2FS_FEATURE_INCOMPAT_EA_INODE)
+            tsk_fprintf(hFile, "Extended Attributes, ");
+        if (tsk_getu32(fs->endian, sb->s_feature_incompat) &
+            EXT2FS_FEATURE_INCOMPAT_DIRDATA)
+            tsk_fprintf(hFile, "Directory Entry Data");
+        
         tsk_fprintf(hFile, "\n");
     }
 
@@ -1669,8 +2018,65 @@
 
             if (tsk_getu32(fs->endian,
                     ext2fs->dino_buf->i_flags) & EXT2_IN_NOA)
-                tsk_fprintf(hFile, "No A-Time, ");
-
+                tsk_fprintf(hFile, "No A-Time, ");   
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_DIRTY)
+                tsk_fprintf(hFile, "Dirty Compressed File, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_COMPRBLK)
+                tsk_fprintf(hFile, "Compressed Clusters, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_NOCOMPR)
+                tsk_fprintf(hFile, "Do Not Compress, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_ECOMPR)
+                tsk_fprintf(hFile, "Compression Error, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_INDEX)
+                tsk_fprintf(hFile, "Hash Indexed Directory, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_IMAGIC)
+                tsk_fprintf(hFile, "AFS Magic Directory, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_JOURNAL_DATA)
+                tsk_fprintf(hFile, "Journal Data, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_NOTAIL)
+                tsk_fprintf(hFile, "Do Not Merge Tail, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_DIRSYNC)
+                tsk_fprintf(hFile, "Directory  Sync, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_TOPDIR)
+                tsk_fprintf(hFile, "Top Directory, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_HUGE_FILE)
+                tsk_fprintf(hFile, "Huge File, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_EXTENTS)
+                tsk_fprintf(hFile, "Extents, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_EA_INODE)
+                tsk_fprintf(hFile, "Large Extended Attribute, ");
+            
+            if (tsk_getu32(fs->endian,
+                    ext2fs->dino_buf->i_flags) & EXT2_IN_EOFBLOCKS)
+                tsk_fprintf(hFile, "Blocks Allocated Beyond EOF, ");
+     
+            
             tsk_fprintf(hFile, "\n");
         }
     }
@@ -1915,6 +2321,12 @@
         tsk_fprintf(hFile, "Accessed:\t%s", ctime(&fs_meta->atime));
         tsk_fprintf(hFile, "File Modified:\t%s", ctime(&fs_meta->mtime));
         tsk_fprintf(hFile, "Inode Modified:\t%s", ctime(&fs_meta->ctime));
+        
+        if (fs->ftype == TSK_FS_TYPE_EXT4) {
+          fs_meta->crtime -= sec_skew;
+          tsk_fprintf(hFile, "File Created:\t%s", ctime(&fs_meta->crtime));
+          fs_meta->crtime += sec_skew;
+        }
 
         if (fs_meta->time2.ext2.dtime) {
             fs_meta->time2.ext2.dtime -= sec_skew;
@@ -1936,6 +2348,9 @@
     tsk_fprintf(hFile, "Accessed:\t%s", ctime(&fs_meta->atime));
     tsk_fprintf(hFile, "File Modified:\t%s", ctime(&fs_meta->mtime));
     tsk_fprintf(hFile, "Inode Modified:\t%s", ctime(&fs_meta->ctime));
+    if (fs_meta->crtime) {
+      tsk_fprintf(hFile, "File Created:\t%s", ctime(&fs_meta->crtime));
+    }
 
     if (fs_meta->time2.ext2.dtime)
         tsk_fprintf(hFile, "Deleted:\t%s",
@@ -1957,23 +2372,43 @@
     }
     else if (print.idx != 0) {
         tsk_fprintf(hFile, "\n");
-    }
-
-    fs_attr_indir = tsk_fs_file_attr_get_type(fs_file,
-        TSK_FS_ATTR_TYPE_UNIX_INDIR, 0, 0);
-    if (fs_attr_indir) {
-        tsk_fprintf(hFile, "\nIndirect Blocks:\n");
-
-        print.idx = 0;
-
-        if (tsk_fs_attr_walk(fs_attr_indir, TSK_FS_FILE_WALK_FLAG_AONLY,
-                print_addr_act, (void *) &print)) {
-            tsk_fprintf(hFile, "\nError reading indirect attribute:  ");
-            tsk_error_print(hFile);
-            tsk_error_reset();
+    }        
+        
+    if (fs_meta->content_type == TSK_FS_META_CONTENT_TYPE_UNIX_EXTENT) {
+        const TSK_FS_ATTR *fs_attr_extent = tsk_fs_file_attr_get_type(fs_file, TSK_FS_ATTR_TYPE_UNIX_EXTENT, 0, 0);
+        if (fs_attr_extent) {
+            tsk_fprintf(hFile, "\nExtent Blocks:\n");
+        
+            print.idx = 0;
+            
+            if (tsk_fs_attr_walk(fs_attr_extent, TSK_FS_FILE_WALK_FLAG_AONLY,
+                    print_addr_act, (void *) &print)) {
+                tsk_fprintf(hFile, "\nError reading indirect attribute:  ");
+                tsk_error_print(hFile);
+                tsk_error_reset();
+            }
+            else if (print.idx != 0) {
+                tsk_fprintf(hFile, "\n");
+            }
         }
-        else if (print.idx != 0) {
-            tsk_fprintf(hFile, "\n");
+    }
+    else {     
+        fs_attr_indir = tsk_fs_file_attr_get_type(fs_file,
+            TSK_FS_ATTR_TYPE_UNIX_INDIR, 0, 0);
+        if (fs_attr_indir) {
+            tsk_fprintf(hFile, "\nIndirect Blocks:\n");
+
+            print.idx = 0;
+
+            if (tsk_fs_attr_walk(fs_attr_indir, TSK_FS_FILE_WALK_FLAG_AONLY,
+                    print_addr_act, (void *) &print)) {
+                tsk_fprintf(hFile, "\nError reading indirect attribute:  ");
+                tsk_error_print(hFile);
+                tsk_error_reset();
+            }
+            else if (print.idx != 0) {
+                tsk_fprintf(hFile, "\n");
+            }
         }
     }
 
@@ -2100,7 +2535,10 @@
 
     /* If autodetect was given, look for the journal */
     if (ftype == TSK_FS_TYPE_EXT_DETECT) {
-        if (tsk_getu32(fs->endian, ext2fs->fs->s_feature_compat) &
+        if (tsk_getu32(fs->endian, ext2fs->fs->s_feature_incompat) &
+            EXT2FS_FEATURE_INCOMPAT_EXTENTS)
+            fs->ftype = TSK_FS_TYPE_EXT4;      
+        else if (tsk_getu32(fs->endian, ext2fs->fs->s_feature_compat) &
             EXT2FS_FEATURE_COMPAT_HAS_JOURNAL)
             fs->ftype = TSK_FS_TYPE_EXT3;
         else
@@ -2141,10 +2579,9 @@
      * size if it is larger */
     ext2fs->inode_size = tsk_getu16(fs->endian, ext2fs->fs->s_inode_size);
     if (ext2fs->inode_size < sizeof(ext2fs_inode)) {
-        ext2fs->inode_size = sizeof(ext2fs_inode);
         if (tsk_verbose)
             tsk_fprintf(stderr,
-                "SB inode size is too small, using default");
+                "SB inode size is small");
     }
 
 
@@ -2205,7 +2642,7 @@
     fs->block_getflags = ext2fs_block_getflags;
 
     fs->get_default_attr_type = tsk_fs_unix_get_default_attr_type;
-    fs->load_attrs = tsk_fs_unix_make_data_run;
+    fs->load_attrs = ext2fs_load_attrs;
 
     fs->file_add_meta = ext2fs_inode_lookup;
     fs->dir_open_meta = ext2fs_dir_open_meta;
diff -Naur sleuthkit-3.2.1-orig/tsk3/fs/fs_file.c sleuthkit-3.2.1-ext4/tsk3/fs/fs_file.c
--- sleuthkit-3.2.1-orig/tsk3/fs/fs_file.c	2011-06-05 21:32:48.734440887 -0400
+++ sleuthkit-3.2.1-ext4/tsk3/fs/fs_file.c	2011-06-05 21:19:35.234441227 -0400
@@ -86,7 +86,7 @@
 * that the returned TSK_FS_FILE structure will not have the file name set because
 * it was not used to load the file and this function does not search the 
 * directory structure to find the name that points to the address.   In general,
-* if you know the metadata address of a file, this function is more effecient 
+* if you know the metadata address of a file, this function is more efficient 
 * then tsk_fs_file_open, which first maps a file name to the metadata address 
 * and then opens the file using this function. 
 *
diff -Naur sleuthkit-3.2.1-orig/tsk3/fs/fs_inode.c sleuthkit-3.2.1-ext4/tsk3/fs/fs_inode.c
--- sleuthkit-3.2.1-orig/tsk3/fs/fs_inode.c	2011-06-05 21:32:48.734440887 -0400
+++ sleuthkit-3.2.1-ext4/tsk3/fs/fs_inode.c	2011-06-05 21:19:35.234441227 -0400
@@ -65,8 +65,7 @@
  * block pointers. 
  *
  * @param fs_meta Structure to resize
- * @param direct_count Number of direct block address pointers to include in structure
- * @param indir_count Number of indirect block address pointers to include in structure
+ * @param a_buf_len Size of file system specific data that is used to store references to file content
  * @return NULL on error 
  */
 TSK_FS_META *
diff -Naur sleuthkit-3.2.1-orig/tsk3/fs/fs_types.c sleuthkit-3.2.1-ext4/tsk3/fs/fs_types.c
--- sleuthkit-3.2.1-orig/tsk3/fs/fs_types.c	2011-06-05 21:32:48.734440887 -0400
+++ sleuthkit-3.2.1-ext4/tsk3/fs/fs_types.c	2011-06-05 21:19:35.244441227 -0400
@@ -51,6 +51,7 @@
     {"fat32", TSK_FS_TYPE_FAT32, "FAT32"},
     {"ext2", TSK_FS_TYPE_EXT2, "Ext2"},
     {"ext3", TSK_FS_TYPE_EXT3, "Ext3"},
+    {"ext4", TSK_FS_TYPE_EXT4, "Ext4"},
     {"ufs1", TSK_FS_TYPE_FFS1, "UFS1"},
     {"ufs2", TSK_FS_TYPE_FFS2, "UFS2"},
     {0},
@@ -61,6 +62,7 @@
     {"linux-ext", TSK_FS_TYPE_EXT_DETECT, "auto-detect Linux EXTxFS"},
     {"linux-ext2", TSK_FS_TYPE_EXT2, "Linux TSK_FS_TYPE_EXT_2"},
     {"linux-ext3", TSK_FS_TYPE_EXT3, "Linux TSK_FS_TYPE_EXT_3"},
+    {"linux-ext4", TSK_FS_TYPE_EXT4, "Linux TSK_FS_TYPE_EXT_4"},
     {"bsdi", TSK_FS_TYPE_FFS1, "BSDi FFS"},
     {"freebsd", TSK_FS_TYPE_FFS1, "FreeBSD FFS"},
     {"netbsd", TSK_FS_TYPE_FFS1, "NetBSD FFS"},
diff -Naur sleuthkit-3.2.1-orig/tsk3/fs/ntfs.c sleuthkit-3.2.1-ext4/tsk3/fs/ntfs.c
--- sleuthkit-3.2.1-orig/tsk3/fs/ntfs.c	2011-06-05 21:32:48.734440887 -0400
+++ sleuthkit-3.2.1-ext4/tsk3/fs/ntfs.c	2011-06-05 21:19:35.244441227 -0400
@@ -57,7 +57,7 @@
  *
  * So, the way this is solved is that generic mft_lookup is used to get
  * any MFT entry, even $MFT.  If $MFT is not cached then we calculate 
- * the address of where to read based on mutliplication and guessing.  
+ * the address of where to read based on multiplication and guessing.  
  * When we are loading the $MFT, we set 'loading_the_MFT' to 1 so
  * that we can update things as we go along.  When we read $MFT we
  * read all the attributes and save info about the $Data one.  If
diff -Naur sleuthkit-3.2.1-orig/tsk3/fs/tsk_ext2fs.h sleuthkit-3.2.1-ext4/tsk3/fs/tsk_ext2fs.h
--- sleuthkit-3.2.1-orig/tsk3/fs/tsk_ext2fs.h	2011-06-05 21:32:48.734440887 -0400
+++ sleuthkit-3.2.1-ext4/tsk3/fs/tsk_ext2fs.h	2011-06-05 21:19:35.234441227 -0400
@@ -77,15 +77,53 @@
         uint8_t s_uuid[16];     /* u8[16] */
         char s_volume_name[16];
         char s_last_mounted[64];
-        uint8_t s_algorithm_usage_bitmap[4];    /* u32 */
+        uint8_t s_algorithm_usage_bitmap[4]; /* u32 */
         uint8_t s_prealloc_blocks;      /* u8 */
         uint8_t s_prealloc_dir_blocks;  /* u8 */
-        uint8_t s_padding1[2];  /* u16 */
+        uint8_t s_padding1[2];          /* u16 */
         uint8_t s_journal_uuid[16];     /* u8[16] */
         uint8_t s_journal_inum[4];      /* u32 */
         uint8_t s_journal_dev[4];       /* u32 */
         uint8_t s_last_orphan[4];       /* u32 */
-        uint8_t s_padding[788];
+        uint8_t s_hash_seed[16];        /* u32[4] */
+        uint8_t s_def_hash_version;     /* u8 */
+        uint8_t s_jnl_backup_type;      /* u8 */
+        uint8_t s_desc_size[2];         /* u16 */
+        uint8_t s_default_mount_opts[4];  /* u32 */
+        uint8_t s_first_meta_bg[4];     /* u32 */
+        uint8_t s_mkfs_time[4];         /* u32 */
+        uint8_t s_jnl_blocks[17 * 4];   /* u32[17] */
+        uint8_t s_blocks_count_hi[4];   /* u32 */
+        uint8_t s_r_blocks_count_hi[4]; /* u32 */
+        uint8_t s_free_blocks_count_hi[4]; /* u32 */
+        uint8_t s_min_extra_isize[2];   /* u16 */
+        uint8_t s_want_extra_isize[2];  /* u16 */
+        uint8_t s_flags[4];             /* u32 */    
+        uint8_t s_raid_stride[2];       /* u16 */
+        uint8_t s_mmp_interval[2];      /* u16 */
+        uint8_t s_mmp_block[8];         /* u64 */
+        uint8_t s_raid_stripe_width[4]; /* u32 */
+        uint8_t s_log_groups_per_flex;  /* u8 */
+        uint8_t s_reserved_char_pad;    /* u8 */
+        uint8_t s_reserved_pad[2];      /* u16 */
+        uint8_t s_kbytes_written[8];    /* u64 */
+        uint8_t s_snapshot_inum[4];     /* u32 */
+        uint8_t s_snapshot_id[4];       /* u32 */
+        uint8_t s_snapshot_r_blocks_count[8]; /* u64 */
+        uint8_t s_snapshot_list[4];     /* u32 */
+        uint8_t s_error_count[4];       /* u32 */
+        uint8_t s_first_error_time[4];  /* u32 */
+        uint8_t s_first_error_ino[4];   /* u32 */
+        uint8_t s_first_error_block[8]; /* u64 */
+        uint8_t s_first_error_func[32]; /* u8[32] */
+        uint8_t s_first_error_line[4];  /* u32 */
+        uint8_t s_last_error_time[4];   /* u32 */
+        uint8_t s_last_error_ino[4];    /* u32 */
+        uint8_t s_last_error_line[4];   /* u32 */
+        uint8_t s_last_error_block[8];  /* u64 */
+        uint8_t s_last_error_func[32];  /* u8[32] */
+        uint8_t s_mount_opts[64];       /* u8[64] */
+        uint8_t s_padding[112 * 4];      
     } ext2fs_sb;
 
 /* File system State Values */
@@ -115,11 +153,21 @@
 #define EXT2FS_FEATURE_INCOMPAT_FILETYPE	0x0002
 #define EXT2FS_FEATURE_INCOMPAT_RECOVER		0x0004
 #define EXT2FS_FEATURE_INCOMPAT_JOURNAL_DEV	0x0008
+#define EXT2FS_FEATURE_INCOMPAT_META_BG         0x0010
+#define EXT2FS_FEATURE_INCOMPAT_EXTENTS         0x0040 
+#define EXT2FS_FEATURE_INCOMPAT_64BIT           0x0080
+#define EXT2FS_FEATURE_INCOMPAT_MMP             0x0100
+#define EXT2FS_FEATURE_INCOMPAT_FLEX_BG         0x0200
+#define EXT2FS_FEATURE_INCOMPAT_EA_INODE        0x0400 
+#define EXT2FS_FEATURE_INCOMPAT_DIRDATA         0x1000 
 
 #define EXT2FS_FEATURE_RO_COMPAT_SPARSE_SUPER	0x0001
-#define EXT2FS_FEATURE_RO_COMPAT_LARGE_FILE		0x0002
-#define EXT2FS_FEATURE_RO_COMPAT_BTREE_DIR		0x0004
-
+#define EXT2FS_FEATURE_RO_COMPAT_LARGE_FILE	0x0002
+#define EXT2FS_FEATURE_RO_COMPAT_BTREE_DIR	0x0004
+#define EXT2FS_FEATURE_RO_COMPAT_HUGE_FILE      0x0008
+#define EXT2FS_FEATURE_RO_COMPAT_GDT_CSUM       0x0010
+#define EXT2FS_FEATURE_RO_COMPAT_DIR_NLINK      0x0020
+#define EXT2FS_FEATURE_RO_COMPAT_EXTRA_ISIZE    0x0040
 
 
 /*
@@ -172,10 +220,40 @@
         uint8_t i_frag;
         uint8_t i_fsize;
         uint8_t f1[2];
-        uint8_t i_uid_high[2];
-        uint8_t i_gid_high[2];
-        uint8_t f7[4];
+        uint8_t i_uid_high[2];     /* u16 */
+        uint8_t i_gid_high[2];     /* u16 */
+        uint8_t f7[4];             /* u32 */
+        uint8_t i_extra_isize[2];  /* u16 */
+        uint8_t i_pad1[2];         /* u16 */
+        uint8_t i_ctime_extra[4];  /* u32 */
+        uint8_t i_mtime_extra[4];  /* u32 */
+        uint8_t i_atime_extra[4];  /* u32 */
+        uint8_t i_crtime[4];       /* u32 */ 
+        uint8_t i_crtime_extra[4]; /* u32 */
+        uint8_t i_version_hi[4];   /* u32 */       
     } ext2fs_inode;
+    
+    typedef struct ext2fs_extent {
+        uint8_t  ee_block[4];       /* u32 */ 
+        uint8_t  ee_len[2];         /* u16 */
+        uint8_t  ee_start_hi[2];    /* u16 */
+        uint8_t  ee_start_lo[4];    /* u32 */ 
+    } ext2fs_extent;
+
+    typedef struct ext2fs_extent_idx {
+        uint8_t  ei_block[4];       /* u32 */ 
+        uint8_t  ei_leaf_lo[4];     /* u32 */ 
+        uint8_t  ei_leaf_hi[2];     /* u16 */
+        uint8_t  ei_unused[2];      /* u16 */
+    } ext2fs_extent_idx;
+
+    typedef struct ext2fs_extent_header {
+        uint8_t  eh_magic[2];       /* u16 */
+        uint8_t  eh_entries[2];     /* u16 */
+        uint8_t  eh_max[2];         /* u16 */
+        uint8_t  eh_depth[2];       /* u16 */
+        uint8_t  eh_generation[4];  /* u32 */ 
+    } ext2fs_extent_header;
 
 /* MODE */
 #define EXT2_IN_FMT  0170000
@@ -209,7 +287,23 @@
 #define EXT2_IN_APPEND 		0x00000020      /* writes to file may only append */
 #define EXT2_IN_NODUMP 		0x00000040      /* do not dump file */
 #define EXT2_IN_NOA		 	0x00000080      /* do not update atime */
-
+#define EXT2_IN_DIRTY                   0x00000100
+#define EXT2_IN_COMPRBLK                0x00000200 /* One or more compressed clusters */
+#define EXT2_IN_NOCOMPR                 0x00000400 /* Don't compress */
+#define EXT2_IN_ECOMPR                  0x00000800 /* Compression error */
+#define EXT2_IN_INDEX                   0x00001000 /* hash-indexed directory */
+#define EXT2_IN_IMAGIC                  0x00002000 /* AFS directory */
+#define EXT2_IN_JOURNAL_DATA            0x00004000 /* file data should be journaled */
+#define EXT2_IN_NOTAIL                  0x00008000 /* file tail should not be merged */
+#define EXT2_IN_DIRSYNC                 0x00010000 /* dirsync behaviour (directories only) */
+#define EXT2_IN_TOPDIR                  0x00020000 /* Top of directory hierarchies*/
+#define EXT2_IN_HUGE_FILE               0x00040000 /* Set to each huge file */
+#define EXT2_IN_EXTENTS                 0x00080000 /* Inode uses extents */
+#define EXT2_IN_EA_INODE                0x00200000 /* Inode used for large EA */
+#define EXT2_IN_EOFBLOCKS               0x00400000 /* Blocks allocated beyond EOF */
+#define EXT2_IN_RESERVED                0x80000000 /* reserved for ext4 lib */
+#define EXT2_IN_USER_VISIBLE            0x004BDFFF /* User visible flags */
+#define EXT2_IN_USER_MODIFIABLE         0x004B80FF /* User modifiable flags */
 
 
 /*
diff -Naur sleuthkit-3.2.1-orig/tsk3/fs/tsk_fs.h sleuthkit-3.2.1-ext4/tsk3/fs/tsk_fs.h
--- sleuthkit-3.2.1-orig/tsk3/fs/tsk_fs.h	2011-06-05 21:32:48.734440887 -0400
+++ sleuthkit-3.2.1-ext4/tsk3/fs/tsk_fs.h	2011-06-05 21:19:35.234441227 -0400
@@ -224,7 +224,8 @@
         TSK_FS_ATTR_TYPE_NTFS_EA = 0xE0,        // 224
         TSK_FS_ATTR_TYPE_NTFS_PROP = 0xF0,      //  (NT)
         TSK_FS_ATTR_TYPE_NTFS_LOG = 0x100,      //  (2K)
-        TSK_FS_ATTR_TYPE_UNIX_INDIR = 0x1001    //  Indirect blocks for UFS and ExtX file systems
+        TSK_FS_ATTR_TYPE_UNIX_INDIR = 0x1001,   //  Indirect blocks for UFS and ExtX file systems
+        TSK_FS_ATTR_TYPE_UNIX_EXTENT = 0x1002   //  Extents for Ext4 file system
     } TSK_FS_ATTR_TYPE_ENUM;
 
 #define TSK_FS_ATTR_ID_DEFAULT  0       ///< Default Data ID used if file system does not assign one.
@@ -398,7 +399,12 @@
     };
     typedef enum TSK_FS_META_MODE_ENUM TSK_FS_META_MODE_ENUM;
 
-
+    typedef enum TSK_FS_META_CONTENT_TYPE_ENUM {
+        TSK_FS_META_CONTENT_TYPE_UNIX_INDIRECT = 0x0,
+        TSK_FS_META_CONTENT_TYPE_UNIX_EXTENT = 0x1
+    } TSK_FS_META_CONTENT_TYPE_ENUM;
+    
+    
 #define TSK_FS_META_TAG 0x13524635
     /** 
      * TSK data structure to store general file and directory metadata. 
@@ -447,6 +453,7 @@
 
         void *content_ptr;      ///< Pointer to file system specific data that is used to store references to file content
         size_t content_len;     ///< size of content  buffer
+        TSK_FS_META_CONTENT_TYPE_ENUM content_type;
 
         uint32_t seq;           ///< Sequence number for file (NTFS only, is incremented when entry is reallocated) 
 
@@ -723,7 +730,7 @@
         TSK_FS_TYPE_FFS_DETECT = 0x00000070,    ///< UFS auto detection
         TSK_FS_TYPE_EXT2 = 0x00000080,  ///< Ext2 file system
         TSK_FS_TYPE_EXT3 = 0x00000100,  ///< Ext3 file system
-        TSK_FS_TYPE_EXT_DETECT = 0x00000180,    ///< ExtX auto detection
+        TSK_FS_TYPE_EXT_DETECT = 0x00002180,    ///< ExtX auto detection
         TSK_FS_TYPE_SWAP = 0x00000200,  ///< SWAP file system
         TSK_FS_TYPE_SWAP_DETECT = 0x00000200,   ///< SWAP auto detection
         TSK_FS_TYPE_RAW = 0x00000400,   ///< RAW file system
@@ -732,6 +739,7 @@
         TSK_FS_TYPE_ISO9660_DETECT = 0x00000800,        ///< ISO9660 auto detection
         TSK_FS_TYPE_HFS = 0x00001000,   ///< HFS file system
         TSK_FS_TYPE_HFS_DETECT = 0x00001000,    ///< HFS auto detection
+	TSK_FS_TYPE_EXT4 = 0x00002000,  ///< Ext3 file system
         TSK_FS_TYPE_UNSUPP = 0xffffffff,        ///< Unsupported file system
     };
     typedef enum TSK_FS_TYPE_ENUM TSK_FS_TYPE_ENUM;
