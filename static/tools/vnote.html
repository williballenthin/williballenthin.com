<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="vnote">
  <meta name="theme-color" content="#f0f0f0">
  <title>vnote</title>
  <link rel="manifest" href="/tools/vnote-manifest.json">
  <link rel="icon" href="/tools/vnote-icon.svg" type="image/svg+xml">
  <link rel="apple-touch-icon" href="/tools/vnote-icon.svg">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    button {
      padding: 8px 16px;
      font-size: 14px;
      border: 1px solid #999;
      background-color: #f5f5f5;
      cursor: pointer;
    }
    button:hover {
      background-color: #e8e8e8;
    }
    button:active {
      background-color: #ddd;
    }
    html, body {
      height: 100%;
    }
    .hidden {
      display: none !important;
    }
    #startScreen {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    .top-bar {
      display: flex;
      justify-content: flex-end;
      padding: 10px;
    }
    .content-area {
      flex: 0 0 auto;
      padding: 10px;
    }
    .button-area {
      flex: 1;
      display: flex;
      padding: 10px;
      min-height: 50vh;
    }
    #mainRecordButton {
      flex: 1;
      font-size: 24px;
      font-weight: bold;
      border: 3px solid black;
      background-color: #f0f0f0;
      cursor: pointer;
    }
    #mainRecordButton:active {
      background-color: #e0e0e0;
    }
    #mainRecordButton.recording {
      background-color: #ffcccc;
      border-color: #cc0000;
    }
    details summary {
      cursor: pointer;
      padding: 5px 0;
    }
    #historyTable {
      width: 100%;
      margin-top: 10px;
    }
    #recordingInfo {
      margin-top: 15px;
      padding: 10px;
      border: 1px solid #ccc;
      background-color: #fafafa;
    }
    #status {
      font-weight: bold;
    }
    #timer {
      font-size: 20px;
      font-family: monospace;
      margin: 5px 0;
    }
    #transcriptContainer {
      margin-top: 10px;
    }
    #transcript {
      min-height: 50px;
      max-height: 30vh;
      overflow-y: auto;
      padding: 8px;
      background: white;
      border: 1px solid #ddd;
      margin-top: 5px;
    }
    .interim {
      color: #666;
      font-style: italic;
    }
    #volumeMeter {
      height: 8px;
      background: #ddd;
      margin: 10px 0;
      overflow: hidden;
    }
    #volumeBar {
      height: 100%;
      width: 0%;
      background: #666;
      transition: width 50ms ease-out;
    }
    #pauseButton {
      margin-left: 10px;
    }
  </style>
</head>
<body>
  <!-- Initial start screen (needed for user gesture to enable permissions) -->
  <div id="startScreen">
    <div class="top-bar">
      <button id="settingsButton">Settings</button>
    </div>
    <div class="content-area">
      <p id="emailDisplay"></p>
      <details id="historySection">
        <summary>History</summary>
        <table id="historyTable">
          <tbody id="historyBody"></tbody>
        </table>
      </details>
      <div id="recordingInfo" class="hidden">
        <div id="status">Initializing...</div>
        <div id="timer">0:00</div>
        <div id="volumeMeter"><div id="volumeBar"></div></div>
        <div id="transcriptContainer">
          <div>Live Transcript</div>
          <div id="transcript">Listening...</div>
        </div>
        <button id="copyButton">Copy Transcript</button>
        <button id="pauseButton">Pause</button>
      </div>
    </div>
    <div class="button-area">
      <button id="mainRecordButton">Start Recording</button>
    </div>
  </div>


  <!-- Settings dialog -->
  <div id="settingsDialog" class="hidden">
    <div id="settingsContent">
      <h2>Settings</h2>
      <label for="emailInput">Email address for transcripts:</label>
      <input type="email" id="emailInput" placeholder="email@example.com">
      <p>Leave empty to use share sheet instead.</p>
      <div>
        <button id="saveSettingsButton">Save</button>
        <button id="cancelSettingsButton">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let mediaRecorder = null;
    let audioChunks = [];
    let recognition = null;
    let finalTranscript = '';
    let interimTranscript = '';
    let startTime = null;
    let pausedTime = 0;
    let timerInterval = null;
    let audioContext = null;
    let analyser = null;
    let volumeAnimationFrame = null;
    let draftSaveInterval = null;
    const DRAFT_STORAGE_KEY = 'vnote_draft';

    // LocalStorage keys
    const EMAIL_STORAGE_KEY = 'vnote_email';
    const HISTORY_STORAGE_KEY = 'vnote_history';

    // DOM Elements
    const startScreen = document.getElementById('startScreen');
    const recordingInfo = document.getElementById('recordingInfo');
    const settingsDialog = document.getElementById('settingsDialog');
    const mainRecordButton = document.getElementById('mainRecordButton');
    const copyButton = document.getElementById('copyButton');
    const pauseButton = document.getElementById('pauseButton');
    const volumeBar = document.getElementById('volumeBar');
    const historySummary = document.querySelector('#historySection summary');
    const settingsButton = document.getElementById('settingsButton');
    const saveSettingsButton = document.getElementById('saveSettingsButton');
    const cancelSettingsButton = document.getElementById('cancelSettingsButton');
    const emailInput = document.getElementById('emailInput');
    const emailDisplay = document.getElementById('emailDisplay');
    const statusEl = document.getElementById('status');
    const timerEl = document.getElementById('timer');
    const transcriptEl = document.getElementById('transcript');
    const historyBody = document.getElementById('historyBody');

    // Load email from localStorage
    function loadEmail() {
      return localStorage.getItem(EMAIL_STORAGE_KEY) || '';
    }

    // Save email to localStorage
    function saveEmail(email) {
      if (email) {
        localStorage.setItem(EMAIL_STORAGE_KEY, email);
      } else {
        localStorage.removeItem(EMAIL_STORAGE_KEY);
      }
    }

    // Update email display on start screen
    function updateEmailDisplay() {
      const email = loadEmail();
      if (email) {
        emailDisplay.textContent = `Email: ${email}`;
      } else {
        emailDisplay.textContent = 'No email configured (will use share sheet)';
      }
    }

    // Load history from localStorage
    function loadHistory() {
      const data = localStorage.getItem(HISTORY_STORAGE_KEY);
      return data ? JSON.parse(data) : [];
    }

    // Save history to localStorage
    function saveHistory(history) {
      localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
    }

    // Add transcription to history
    function addToHistory(transcript) {
      const history = loadHistory();
      const entry = {
        date: new Date().toISOString(),
        text: transcript
      };
      history.unshift(entry); // Add to beginning
      // Keep only last 50 entries
      if (history.length > 50) {
        history.pop();
      }
      saveHistory(history);
      renderHistory();
    }

    // Delete entry from history
    function deleteHistoryEntry(index) {
      const history = loadHistory();
      history.splice(index, 1);
      saveHistory(history);
      renderHistory();
    }

    // Update history count in summary
    function updateHistoryCount() {
      const history = loadHistory();
      const count = history.length;
      historySummary.textContent = count > 0 ? `History (${count})` : 'History';
    }

    // Generate email subject with timestamp
    function generateEmailSubjectForDate(dateStr) {
      const date = new Date(dateStr);
      return `Voice Note - ${date.toLocaleString()}`;
    }

    // Send email for a transcript
    function sendEmailForTranscript(text, dateStr) {
      const email = loadEmail();
      if (!email) {
        alert('No email configured. Go to Settings to add one.');
        return;
      }
      const subject = encodeURIComponent(generateEmailSubjectForDate(dateStr));
      const body = encodeURIComponent(text);
      const mailtoUrl = `mailto:${email}?subject=${subject}&body=${body}`;
      window.location.href = mailtoUrl;
    }

    // Copy text to clipboard
    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (e) {
        console.error('Copy failed:', e);
        return false;
      }
    }

    // Render history table
    function renderHistory() {
      const history = loadHistory();
      historyBody.innerHTML = '';
      updateHistoryCount();

      if (history.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = '<td colspan="5">No history yet</td>';
        historyBody.appendChild(row);
        return;
      }

      history.forEach((entry, index) => {
        const row = document.createElement('tr');
        const date = new Date(entry.date);
        const preview = entry.text.substring(0, 32) + (entry.text.length > 32 ? '...' : '');

        const dateCell = document.createElement('td');
        dateCell.textContent = date.toLocaleString();

        const previewCell = document.createElement('td');
        previewCell.textContent = preview;

        const copyCell = document.createElement('td');
        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.onclick = async () => {
          if (await copyToClipboard(entry.text)) {
            copyBtn.textContent = 'Copied!';
            setTimeout(() => copyBtn.textContent = 'Copy', 1500);
          }
        };
        copyCell.appendChild(copyBtn);

        const emailCell = document.createElement('td');
        const emailBtn = document.createElement('button');
        emailBtn.textContent = 'Email';
        emailBtn.onclick = () => sendEmailForTranscript(entry.text, entry.date);
        emailCell.appendChild(emailBtn);

        const deleteCell = document.createElement('td');
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = 'Delete';
        deleteBtn.onclick = () => {
          if (confirm('Delete this entry?')) {
            deleteHistoryEntry(index);
          }
        };
        deleteCell.appendChild(deleteBtn);

        row.appendChild(dateCell);
        row.appendChild(previewCell);
        row.appendChild(copyCell);
        row.appendChild(emailCell);
        row.appendChild(deleteCell);
        historyBody.appendChild(row);
      });
    }

    // Show settings dialog
    function showSettings() {
      emailInput.value = loadEmail();
      settingsDialog.classList.remove('hidden');
    }

    // Hide settings dialog
    function hideSettings() {
      settingsDialog.classList.add('hidden');
    }

    // Save settings
    function saveSettings() {
      saveEmail(emailInput.value.trim());
      updateEmailDisplay();
      hideSettings();
    }

    // Format time as M:SS
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Update timer display
    function updateTimer() {
      if (startTime) {
        const elapsed = (pausedTime + Date.now() - startTime) / 1000;
        timerEl.textContent = formatTime(elapsed);
      }
    }

    // Generate ISO 8601 filename
    function generateFilename() {
      const now = new Date();
      const iso = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
      return `${iso}-transcription`;
    }

    // Generate email subject with timestamp
    function generateEmailSubject() {
      const now = new Date();
      return `Voice Note - ${now.toLocaleString()}`;
    }

    // Update transcript display
    function updateTranscriptDisplay() {
      if (finalTranscript || interimTranscript) {
        transcriptEl.innerHTML = '';
        if (finalTranscript) {
          const finalSpan = document.createElement('span');
          finalSpan.textContent = finalTranscript;
          transcriptEl.appendChild(finalSpan);
        }
        if (interimTranscript) {
          const interimSpan = document.createElement('span');
          interimSpan.className = 'interim';
          interimSpan.textContent = interimTranscript;
          transcriptEl.appendChild(interimSpan);
        }
      } else {
        transcriptEl.textContent = 'Listening...';
      }
      // Auto-scroll to bottom
      transcriptEl.scrollTop = transcriptEl.scrollHeight;
    }

    // Copy current transcript
    async function copyCurrentTranscript() {
      const text = finalTranscript.trim() || interimTranscript.trim();
      if (!text) {
        copyButton.textContent = 'Nothing to copy';
        setTimeout(() => copyButton.textContent = 'Copy Transcript', 1500);
        return;
      }
      if (await copyToClipboard(text)) {
        copyButton.textContent = 'Copied!';
        setTimeout(() => copyButton.textContent = 'Copy Transcript', 1500);
      }
    }

    // Initialize speech recognition
    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

      if (!SpeechRecognition) {
        console.warn('Speech recognition not supported');
        return null;
      }

      const recog = new SpeechRecognition();
      recog.continuous = true;
      recog.interimResults = true;
      recog.lang = 'en-US';

      recog.onresult = (event) => {
        interimTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const result = event.results[i];
          if (result.isFinal) {
            finalTranscript += result[0].transcript + ' ';
          } else {
            interimTranscript += result[0].transcript;
          }
        }

        updateTranscriptDisplay();
      };

      recog.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        if (event.error === 'no-speech') {
          // Restart on no-speech timeout
          try {
            recog.stop();
            setTimeout(() => {
              if (mediaRecorder && mediaRecorder.state === 'recording') {
                recog.start();
              }
            }, 100);
          } catch (e) {}
        }
      };

      recog.onend = () => {
        // Auto-restart if still recording
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          try {
            recog.start();
          } catch (e) {}
        }
      };

      return recog;
    }

    // Volume meter using Web Audio API
    function startVolumeMeter(stream) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      analyser = audioContext.createAnalyser();
      const source = audioContext.createMediaStreamSource(stream);
      source.connect(analyser);
      analyser.fftSize = 256;
      const dataArray = new Uint8Array(analyser.frequencyBinCount);

      function updateVolume() {
        if (!analyser) return;
        analyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
        const volume = Math.min(100, (average / 128) * 100);
        volumeBar.style.width = volume + '%';
        volumeAnimationFrame = requestAnimationFrame(updateVolume);
      }
      updateVolume();
    }

    function stopVolumeMeter() {
      if (volumeAnimationFrame) {
        cancelAnimationFrame(volumeAnimationFrame);
        volumeAnimationFrame = null;
      }
      if (audioContext) {
        audioContext.close();
        audioContext = null;
        analyser = null;
      }
      volumeBar.style.width = '0%';
    }

    // Draft save/load/clear
    function saveDraft() {
      const draft = {
        finalTranscript,
        interimTranscript,
        savedAt: new Date().toISOString()
      };
      localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft));
    }

    function loadDraft() {
      const data = localStorage.getItem(DRAFT_STORAGE_KEY);
      return data ? JSON.parse(data) : null;
    }

    function clearDraft() {
      localStorage.removeItem(DRAFT_STORAGE_KEY);
    }

    function startDraftSaving() {
      draftSaveInterval = setInterval(saveDraft, 5000); // Save every 5 seconds
    }

    function stopDraftSaving() {
      if (draftSaveInterval) {
        clearInterval(draftSaveInterval);
        draftSaveInterval = null;
      }
    }

    // Pause/Resume recording
    function pauseRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.pause();
        if (recognition) {
          recognition.stop();
        }
        pausedTime += Date.now() - startTime;
        startTime = null;
        clearInterval(timerInterval);
        pauseButton.textContent = 'Resume';
        statusEl.textContent = 'Paused';
      }
    }

    function resumeRecording() {
      if (mediaRecorder && mediaRecorder.state === 'paused') {
        mediaRecorder.resume();
        if (recognition) {
          recognition.start();
        }
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 100);
        pauseButton.textContent = 'Pause';
        statusEl.textContent = 'Recording';
      }
    }

    function togglePause() {
      if (mediaRecorder) {
        if (mediaRecorder.state === 'recording') {
          pauseRecording();
        } else if (mediaRecorder.state === 'paused') {
          resumeRecording();
        }
      }
    }

    // Start recording
    async function startRecording() {
      try {
        // Update button to show recording state
        mainRecordButton.textContent = 'Stop Recording';
        mainRecordButton.classList.add('recording');

        // Show recording info section
        recordingInfo.classList.remove('hidden');

        statusEl.textContent = 'Requesting microphone access...';

        // Get microphone access
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            sampleRate: 44100
          }
        });

        // Determine supported MIME type
        let mimeType = 'audio/mp4';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = 'audio/webm;codecs=opus';
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'audio/webm';
          }
        }

        // Initialize MediaRecorder
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());

          // Process and share
          await processAndShare();
        };

        // Start recording
        mediaRecorder.start(1000); // Capture in 1-second chunks

        // Start volume meter
        startVolumeMeter(stream);

        // Start timer
        startTime = Date.now();
        pausedTime = 0;
        timerInterval = setInterval(updateTimer, 100);

        // Initialize and start speech recognition
        recognition = initSpeechRecognition();
        if (recognition) {
          recognition.start();
        }

        // Start auto-saving drafts
        startDraftSaving();

        // Reset pause button
        pauseButton.textContent = 'Pause';

        // Update UI
        statusEl.textContent = 'Recording';

      } catch (error) {
        console.error('Error starting recording:', error);
        statusEl.textContent = `Error: ${error.message}`;

        // Reset button and hide recording info
        setTimeout(() => {
          mainRecordButton.textContent = 'Start Recording';
          mainRecordButton.classList.remove('recording');
          recordingInfo.classList.add('hidden');
        }, 2000);
      }
    }

    // Stop recording
    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        // Stop speech recognition
        if (recognition) {
          recognition.stop();
        }

        // Stop timer
        clearInterval(timerInterval);

        // Stop volume meter
        stopVolumeMeter();

        // Stop draft saving and clear draft
        stopDraftSaving();
        clearDraft();

        // Update UI
        statusEl.textContent = 'Processing...';

        // Stop recording (triggers onstop handler)
        mediaRecorder.stop();
      }
    }

    // Process recording and share
    async function processAndShare() {
      try {
        // Prepare transcript
        const transcriptText = finalTranscript.trim() || '(No transcript captured)';

        // Save to history
        if (transcriptText !== '(No transcript captured)') {
          addToHistory(transcriptText);
        }

        // Check if email is configured
        const email = loadEmail();

        if (email) {
          // Use mailto link
          statusEl.textContent = 'Opening email...';
          const subject = encodeURIComponent(generateEmailSubject());
          const body = encodeURIComponent(transcriptText);
          const mailtoUrl = `mailto:${email}?subject=${subject}&body=${body}`;
          window.location.href = mailtoUrl;
          statusEl.textContent = 'Email opened!';
        } else {
          // Use share sheet (original behavior)
          statusEl.textContent = 'Preparing to share...';

          // Create audio blob
          const mimeType = mediaRecorder.mimeType;
          const audioBlob = new Blob(audioChunks, { type: mimeType });

          // Determine file extension
          const ext = mimeType.includes('mp4') ? 'm4a' : 'webm';
          const filename = `${generateFilename()}.${ext}`;

          // Create file
          const audioFile = new File([audioBlob], filename, { type: mimeType });

          // Check if we can share files
          if (navigator.canShare && navigator.canShare({ files: [audioFile] })) {
            await navigator.share({
              files: [audioFile],
              title: 'Voice Note',
              text: `Transcript:\n${transcriptText}`
            });
            statusEl.textContent = 'Shared successfully!';
          } else {
            // Fallback: offer download
            statusEl.textContent = 'Share not supported, downloading...';
            const url = URL.createObjectURL(audioBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            // Also show transcript
            alert(`Transcript:\n\n${transcriptText}`);
          }
        }

        // Reset for next recording
        setTimeout(() => {
          resetState();
        }, 1500);

      } catch (error) {
        if (error.name === 'AbortError') {
          statusEl.textContent = 'Share cancelled';
        } else {
          console.error('Error sharing:', error);
          statusEl.textContent = `Error: ${error.message}`;
        }

        setTimeout(() => {
          resetState();
        }, 1500);
      }
    }

    // Reset to initial state
    function resetState() {
      mediaRecorder = null;
      audioChunks = [];
      recognition = null;
      finalTranscript = '';
      interimTranscript = '';
      startTime = null;
      pausedTime = 0;

      timerEl.textContent = '0:00';
      transcriptEl.textContent = 'Listening...';
      pauseButton.textContent = 'Pause';

      // Reset main button state and hide recording info
      mainRecordButton.textContent = 'Start Recording';
      mainRecordButton.classList.remove('recording');
      recordingInfo.classList.add('hidden');
    }

    // Toggle recording on main button click
    function toggleRecording() {
      if (mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')) {
        stopRecording();
      } else {
        startRecording();
      }
    }

    // Check for recovered draft on load
    function checkForDraft() {
      const draft = loadDraft();
      if (draft && draft.finalTranscript) {
        const savedAt = new Date(draft.savedAt).toLocaleString();
        if (confirm(`Found unsaved draft from ${savedAt}. Recover it?`)) {
          addToHistory(draft.finalTranscript);
        }
        clearDraft();
      }
    }

    // Event listeners
    mainRecordButton.addEventListener('click', toggleRecording);
    pauseButton.addEventListener('click', togglePause);
    copyButton.addEventListener('click', copyCurrentTranscript);
    settingsButton.addEventListener('click', showSettings);
    saveSettingsButton.addEventListener('click', saveSettings);
    cancelSettingsButton.addEventListener('click', hideSettings);

    // Prevent accidental navigation
    window.addEventListener('beforeunload', (e) => {
      if (mediaRecorder && (mediaRecorder.state === 'recording' || mediaRecorder.state === 'paused')) {
        e.preventDefault();
        e.returnValue = '';
      }
    });

    // Initialize on load
    updateEmailDisplay();
    renderHistory();
    checkForDraft();

    // Register service worker for offline support
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/tools/vnote-sw.js')
        .then((reg) => console.log('Service worker registered'))
        .catch((err) => console.warn('Service worker registration failed:', err));
    }
  </script>

</body>
</html>
