<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Voice Note</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <!-- Initial start screen (needed for user gesture to enable permissions) -->
  <div id="startScreen">
    <p>Tap to start recording</p>
    <button id="startButton">Start Recording</button>
    <button id="settingsButton">Settings</button>
  </div>

  <!-- Recording screen -->
  <div id="recordingScreen" class="hidden">
    <div id="status">Initializing...</div>
    <div id="timer">0:00</div>
    <button id="stopButton" disabled>Stop</button>
    <div id="transcriptContainer">
      <div>Live Transcript</div>
      <div id="transcript">Listening...</div>
    </div>
  </div>

  <!-- Settings dialog -->
  <div id="settingsDialog" class="hidden">
    <div id="settingsContent">
      <h2>Settings</h2>
      <label for="emailInput">Email address for transcripts:</label>
      <input type="email" id="emailInput" placeholder="email@example.com">
      <p>Leave empty to use share sheet instead.</p>
      <div>
        <button id="saveSettingsButton">Save</button>
        <button id="cancelSettingsButton">Cancel</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let mediaRecorder = null;
    let audioChunks = [];
    let recognition = null;
    let finalTranscript = '';
    let interimTranscript = '';
    let startTime = null;
    let timerInterval = null;

    // LocalStorage key
    const EMAIL_STORAGE_KEY = 'vnote_email';

    // DOM Elements
    const startScreen = document.getElementById('startScreen');
    const recordingScreen = document.getElementById('recordingScreen');
    const settingsDialog = document.getElementById('settingsDialog');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const settingsButton = document.getElementById('settingsButton');
    const saveSettingsButton = document.getElementById('saveSettingsButton');
    const cancelSettingsButton = document.getElementById('cancelSettingsButton');
    const emailInput = document.getElementById('emailInput');
    const statusEl = document.getElementById('status');
    const timerEl = document.getElementById('timer');
    const transcriptEl = document.getElementById('transcript');

    // Load email from localStorage
    function loadEmail() {
      return localStorage.getItem(EMAIL_STORAGE_KEY) || '';
    }

    // Save email to localStorage
    function saveEmail(email) {
      if (email) {
        localStorage.setItem(EMAIL_STORAGE_KEY, email);
      } else {
        localStorage.removeItem(EMAIL_STORAGE_KEY);
      }
    }

    // Show settings dialog
    function showSettings() {
      emailInput.value = loadEmail();
      settingsDialog.classList.remove('hidden');
    }

    // Hide settings dialog
    function hideSettings() {
      settingsDialog.classList.add('hidden');
    }

    // Save settings
    function saveSettings() {
      saveEmail(emailInput.value.trim());
      hideSettings();
    }

    // Format time as M:SS
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Update timer display
    function updateTimer() {
      if (startTime) {
        const elapsed = (Date.now() - startTime) / 1000;
        timerEl.textContent = formatTime(elapsed);
      }
    }

    // Generate ISO 8601 filename
    function generateFilename() {
      const now = new Date();
      const iso = now.toISOString().replace(/[:.]/g, '-').slice(0, -5);
      return `${iso}-transcription`;
    }

    // Generate email subject with timestamp
    function generateEmailSubject() {
      const now = new Date();
      return `Voice Note - ${now.toLocaleString()}`;
    }

    // Update transcript display
    function updateTranscriptDisplay() {
      if (finalTranscript || interimTranscript) {
        transcriptEl.textContent = finalTranscript + interimTranscript;
      } else {
        transcriptEl.textContent = 'Listening...';
      }
    }

    // Initialize speech recognition
    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

      if (!SpeechRecognition) {
        console.warn('Speech recognition not supported');
        return null;
      }

      const recog = new SpeechRecognition();
      recog.continuous = true;
      recog.interimResults = true;
      recog.lang = 'en-US';

      recog.onresult = (event) => {
        interimTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; i++) {
          const result = event.results[i];
          if (result.isFinal) {
            finalTranscript += result[0].transcript + ' ';
          } else {
            interimTranscript += result[0].transcript;
          }
        }

        updateTranscriptDisplay();
      };

      recog.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        if (event.error === 'no-speech') {
          // Restart on no-speech timeout
          try {
            recog.stop();
            setTimeout(() => {
              if (mediaRecorder && mediaRecorder.state === 'recording') {
                recog.start();
              }
            }, 100);
          } catch (e) {}
        }
      };

      recog.onend = () => {
        // Auto-restart if still recording
        if (mediaRecorder && mediaRecorder.state === 'recording') {
          try {
            recog.start();
          } catch (e) {}
        }
      };

      return recog;
    }

    // Start recording
    async function startRecording() {
      try {
        // Switch screens
        startScreen.classList.add('hidden');
        recordingScreen.classList.remove('hidden');

        statusEl.textContent = 'Requesting microphone access...';

        // Get microphone access
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            sampleRate: 44100
          }
        });

        // Determine supported MIME type
        let mimeType = 'audio/mp4';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
          mimeType = 'audio/webm;codecs=opus';
          if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'audio/webm';
          }
        }

        // Initialize MediaRecorder
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data);
          }
        };

        mediaRecorder.onstop = async () => {
          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());

          // Process and share
          await processAndShare();
        };

        // Start recording
        mediaRecorder.start(1000); // Capture in 1-second chunks

        // Start timer
        startTime = Date.now();
        timerInterval = setInterval(updateTimer, 100);

        // Initialize and start speech recognition
        recognition = initSpeechRecognition();
        if (recognition) {
          recognition.start();
        }

        // Update UI
        statusEl.textContent = 'Recording';
        stopButton.disabled = false;

      } catch (error) {
        console.error('Error starting recording:', error);
        statusEl.textContent = `Error: ${error.message}`;

        // Show start screen again
        setTimeout(() => {
          recordingScreen.classList.add('hidden');
          startScreen.classList.remove('hidden');
        }, 2000);
      }
    }

    // Stop recording
    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        // Stop speech recognition
        if (recognition) {
          recognition.stop();
        }

        // Stop timer
        clearInterval(timerInterval);

        // Update UI
        statusEl.textContent = 'Processing...';
        stopButton.disabled = true;

        // Stop recording (triggers onstop handler)
        mediaRecorder.stop();
      }
    }

    // Process recording and share
    async function processAndShare() {
      try {
        // Prepare transcript
        const transcriptText = finalTranscript.trim() || '(No transcript captured)';

        // Check if email is configured
        const email = loadEmail();

        if (email) {
          // Use mailto link
          statusEl.textContent = 'Opening email...';
          const subject = encodeURIComponent(generateEmailSubject());
          const body = encodeURIComponent(transcriptText);
          const mailtoUrl = `mailto:${email}?subject=${subject}&body=${body}`;
          window.location.href = mailtoUrl;
          statusEl.textContent = 'Email opened!';
        } else {
          // Use share sheet (original behavior)
          statusEl.textContent = 'Preparing to share...';

          // Create audio blob
          const mimeType = mediaRecorder.mimeType;
          const audioBlob = new Blob(audioChunks, { type: mimeType });

          // Determine file extension
          const ext = mimeType.includes('mp4') ? 'm4a' : 'webm';
          const filename = `${generateFilename()}.${ext}`;

          // Create file
          const audioFile = new File([audioBlob], filename, { type: mimeType });

          // Check if we can share files
          if (navigator.canShare && navigator.canShare({ files: [audioFile] })) {
            await navigator.share({
              files: [audioFile],
              title: 'Voice Note',
              text: `Transcript:\n${transcriptText}`
            });
            statusEl.textContent = 'Shared successfully!';
          } else {
            // Fallback: offer download
            statusEl.textContent = 'Share not supported, downloading...';
            const url = URL.createObjectURL(audioBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            // Also show transcript
            alert(`Transcript:\n\n${transcriptText}`);
          }
        }

        // Reset for next recording
        setTimeout(() => {
          resetState();
        }, 1500);

      } catch (error) {
        if (error.name === 'AbortError') {
          statusEl.textContent = 'Share cancelled';
        } else {
          console.error('Error sharing:', error);
          statusEl.textContent = `Error: ${error.message}`;
        }

        setTimeout(() => {
          resetState();
        }, 1500);
      }
    }

    // Reset to initial state
    function resetState() {
      mediaRecorder = null;
      audioChunks = [];
      recognition = null;
      finalTranscript = '';
      interimTranscript = '';
      startTime = null;

      timerEl.textContent = '0:00';
      transcriptEl.textContent = 'Listening...';

      recordingScreen.classList.add('hidden');
      startScreen.classList.remove('hidden');
    }

    // Event listeners
    startButton.addEventListener('click', startRecording);
    stopButton.addEventListener('click', stopRecording);
    settingsButton.addEventListener('click', showSettings);
    saveSettingsButton.addEventListener('click', saveSettings);
    cancelSettingsButton.addEventListener('click', hideSettings);

    // Prevent accidental navigation
    window.addEventListener('beforeunload', (e) => {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        e.preventDefault();
        e.returnValue = '';
      }
    });
  </script>

</body>
</html>
